<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link href="../common/css/tapl.css" rel="stylesheet" type="text/css" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>PLF.IMP</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library PLF.IMP</h1>

<div class="code">
<span class="id" title="keyword">Set</span> <span class="id" title="var">Warnings</span> "-notation-overridden,-notation-incompatible-prefix".<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Bool</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Init.Nat</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Arith</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">EqNat</span>. <span class="id" title="keyword">Import</span> <span class="id" title="module">Nat</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Lia</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">List</span>. <span class="id" title="keyword">Import</span> <span class="id" title="module">ListNotations</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">Stdlib</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Strings.String</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">PLF</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="PLF.Maps.html#"><span class="id" title="library">Maps</span></a>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Default</span> <span class="id" title="keyword">Goal</span> <span class="id" title="var">Selector</span> "!".<br/>
</div>

<div class="doc">
<a id="lab142"></a><h2 class="section">States</h2>

<div class="paragraph"> </div>

 Since we'll want to look variables up to find out their current
    values, we'll use total maps from the <span class="inlinecode"><span class="id" title="var">Maps</span></span> chapter.

<div class="paragraph"> </div>

    A <i>machine state</i> (or just <i>state</i>) represents the current values
    of all variables at some point in the execution of a program. 
<div class="paragraph"> </div>

 For simplicity, we assume that the state is defined for
    <i>all</i> variables, even though any given program is only able to
    mention a finite number of them.  Because each variable stores a
    natural number, we can represent the state as a total map from
    strings (variable names) to <span class="inlinecode"><span class="id" title="var">nat</span></span>, and will use <span class="inlinecode">0</span> as default
    value in the store. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="state" class="idref" href="#state"><span class="id" title="definition">state</span></a> := <a class="idref" href="PLF.Maps.html#total_map"><span class="id" title="definition">total_map</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab143"></a><h2 class="section">Syntax</h2>

<div class="paragraph"> </div>

 We can add variables to the arithmetic expressions we had before
    simply by including one more constructor: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a id="aexp" class="idref" href="#aexp"><span class="id" title="definition, inductive"><span id="aexp_rect" class="id"><span id="aexp_ind" class="id"><span id="aexp_rec" class="id"><span id="aexp_sind" class="id">aexp</span></span></span></span></span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="ANum" class="idref" href="#ANum"><span class="id" title="constructor">ANum</span></a> (<a id="n:3" class="idref" href="#n:3"><span class="id" title="binder">n</span></a> : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;| <a id="AId" class="idref" href="#AId"><span class="id" title="constructor">AId</span></a> (<a id="x:4" class="idref" href="#x:4"><span class="id" title="binder">x</span></a> : <span class="id" title="inductive">string</span>)              <br/>
&nbsp;&nbsp;| <a id="APlus" class="idref" href="#APlus"><span class="id" title="constructor">APlus</span></a> (<a id="a1:5" class="idref" href="#a1:5"><span class="id" title="binder">a1</span></a> <a id="a2:6" class="idref" href="#a2:6"><span class="id" title="binder">a2</span></a> : <a class="idref" href="PLF.IMP.html#aexp:1"><span class="id" title="inductive">aexp</span></a>)<br/>
&nbsp;&nbsp;| <a id="AMinus" class="idref" href="#AMinus"><span class="id" title="constructor">AMinus</span></a> (<a id="a1:7" class="idref" href="#a1:7"><span class="id" title="binder">a1</span></a> <a id="a2:8" class="idref" href="#a2:8"><span class="id" title="binder">a2</span></a> : <a class="idref" href="PLF.IMP.html#aexp:1"><span class="id" title="inductive">aexp</span></a>)<br/>
&nbsp;&nbsp;| <a id="AMult" class="idref" href="#AMult"><span class="id" title="constructor">AMult</span></a> (<a id="a1:9" class="idref" href="#a1:9"><span class="id" title="binder">a1</span></a> <a id="a2:10" class="idref" href="#a2:10"><span class="id" title="binder">a2</span></a> : <a class="idref" href="PLF.IMP.html#aexp:1"><span class="id" title="inductive">aexp</span></a>).<br/>

<br/>
</div>

<div class="doc">
Defining a few variable names as notational shorthands will make
    examples easier to read: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="W" class="idref" href="#W"><span class="id" title="definition">W</span></a> : <span class="id" title="inductive">string</span> := "W".<br/>
<span class="id" title="keyword">Definition</span> <a id="X" class="idref" href="#X"><span class="id" title="definition">X</span></a> : <span class="id" title="inductive">string</span> := "X".<br/>
<span class="id" title="keyword">Definition</span> <a id="Y" class="idref" href="#Y"><span class="id" title="definition">Y</span></a> : <span class="id" title="inductive">string</span> := "Y".<br/>
<span class="id" title="keyword">Definition</span> <a id="Z" class="idref" href="#Z"><span class="id" title="definition">Z</span></a> : <span class="id" title="inductive">string</span> := "Z".<br/>

<br/>
</div>

<div class="doc">
(This convention for naming program variables (<span class="inlinecode"><span class="id" title="var">X</span></span>, <span class="inlinecode"><span class="id" title="var">Y</span></span>,
    <span class="inlinecode"><span class="id" title="var">Z</span></span>) clashes a bit with our earlier use of uppercase letters for
    types.  Since we're not using polymorphism heavily in the chapters
    developed to Imp, this overloading should not cause confusion.) 
<div class="paragraph"> </div>

 The definition of <span class="inlinecode"><span class="id" title="var">bexp</span></span>s is unchanged (except that it now refers
    to the new <span class="inlinecode"><span class="id" title="var">aexp</span></span>s): 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a id="bexp" class="idref" href="#bexp"><span class="id" title="definition, inductive"><span id="bexp_rect" class="id"><span id="bexp_ind" class="id"><span id="bexp_rec" class="id"><span id="bexp_sind" class="id">bexp</span></span></span></span></span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="BTrue" class="idref" href="#BTrue"><span class="id" title="constructor">BTrue</span></a><br/>
&nbsp;&nbsp;| <a id="BFalse" class="idref" href="#BFalse"><span class="id" title="constructor">BFalse</span></a><br/>
&nbsp;&nbsp;| <a id="BEq" class="idref" href="#BEq"><span class="id" title="constructor">BEq</span></a> (<a id="a1:13" class="idref" href="#a1:13"><span class="id" title="binder">a1</span></a> <a id="a2:14" class="idref" href="#a2:14"><span class="id" title="binder">a2</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a>)<br/>
&nbsp;&nbsp;| <a id="BNeq" class="idref" href="#BNeq"><span class="id" title="constructor">BNeq</span></a> (<a id="a1:15" class="idref" href="#a1:15"><span class="id" title="binder">a1</span></a> <a id="a2:16" class="idref" href="#a2:16"><span class="id" title="binder">a2</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a>)<br/>
&nbsp;&nbsp;| <a id="BLe" class="idref" href="#BLe"><span class="id" title="constructor">BLe</span></a> (<a id="a1:17" class="idref" href="#a1:17"><span class="id" title="binder">a1</span></a> <a id="a2:18" class="idref" href="#a2:18"><span class="id" title="binder">a2</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a>)<br/>
&nbsp;&nbsp;| <a id="BGt" class="idref" href="#BGt"><span class="id" title="constructor">BGt</span></a> (<a id="a1:19" class="idref" href="#a1:19"><span class="id" title="binder">a1</span></a> <a id="a2:20" class="idref" href="#a2:20"><span class="id" title="binder">a2</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a>)<br/>
&nbsp;&nbsp;| <a id="BNot" class="idref" href="#BNot"><span class="id" title="constructor">BNot</span></a> (<a id="b:21" class="idref" href="#b:21"><span class="id" title="binder">b</span></a> : <a class="idref" href="PLF.IMP.html#bexp:11"><span class="id" title="inductive">bexp</span></a>)<br/>
&nbsp;&nbsp;| <a id="BAnd" class="idref" href="#BAnd"><span class="id" title="constructor">BAnd</span></a> (<a id="b1:22" class="idref" href="#b1:22"><span class="id" title="binder">b1</span></a> <a id="b2:23" class="idref" href="#b2:23"><span class="id" title="binder">b2</span></a> : <a class="idref" href="PLF.IMP.html#bexp:11"><span class="id" title="inductive">bexp</span></a>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab144"></a><h2 class="section">Notations</h2>

<div class="paragraph"> </div>

 To make Imp programs easier to read and write, we introduce some
    notations and implicit coercions.  
<div class="paragraph"> </div>

 You do not need to understand exactly what these declarations do.

<div class="paragraph"> </div>

    Briefly, though:
<ul class="doclist">
<li> The <span class="inlinecode"><span class="id" title="keyword">Coercion</span></span> declaration stipulates that a function (or
         constructor) can be implicitly used by the type system to
         coerce a value of the input type to a value of the output
         type.  For instance, the coercion declaration for <span class="inlinecode"><span class="id" title="var">AId</span></span>
         allows us to use plain strings when an <span class="inlinecode"><span class="id" title="var">aexp</span></span> is expected;
         the string will implicitly be wrapped with <span class="inlinecode"><span class="id" title="var">AId</span></span>.

</li>
<li> <span class="inlinecode"><span class="id" title="var">Declare</span></span> <span class="inlinecode"><span class="id" title="var">Custom</span></span> <span class="inlinecode"><span class="id" title="var">Entry</span></span> <span class="inlinecode"><span class="id" title="var">com</span></span> tells Coq to create a new "custom
         grammar" for parsing Imp expressions and programs. The first
         notation declaration after this tells Coq that anything
         between <span class="inlinecode">&lt;{</span> and <span class="inlinecode">}&gt;</span> should be parsed using the Imp
         grammar. Again, it is not necessary to understand the
         details, but it is important to recognize that we are
         defining <i>new</i> interpretations for some familiar operators
         like <span class="inlinecode">+</span>, <span class="inlinecode">-</span>, <span class="inlinecode">×</span>, <span class="inlinecode">=</span>, <span class="inlinecode">≤</span>, etc., when they occur between
         <span class="inlinecode">&lt;{</span> and <span class="inlinecode">}&gt;</span>. 

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="PLF.IMP.html#AId"><span class="id" title="constructor">AId</span></a> <a class="idref" href="PLF.IMP.html#AId"><span class="id" title="constructor">:</span></a> <a class="idref" href="PLF.IMP.html#AId"><span class="id" title="constructor">string</span></a> <a class="idref" href="PLF.IMP.html#AId"><span class="id" title="constructor">&gt;-&gt;</span></a> <a class="idref" href="PLF.IMP.html#AId"><span class="id" title="constructor">aexp</span></a>.<br/>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="PLF.IMP.html#ANum"><span class="id" title="constructor">ANum</span></a> <a class="idref" href="PLF.IMP.html#ANum"><span class="id" title="constructor">:</span></a> <a class="idref" href="PLF.IMP.html#ANum"><span class="id" title="constructor">nat</span></a> <a class="idref" href="PLF.IMP.html#ANum"><span class="id" title="constructor">&gt;-&gt;</span></a> <a class="idref" href="PLF.IMP.html#ANum"><span class="id" title="constructor">aexp</span></a>.<br/>

<br/>
<span class="id" title="var">Declare</span> <span class="id" title="var">Custom</span> <span class="id" title="var">Entry</span> <span class="id" title="var">com</span>.<br/>
<span class="id" title="keyword">Declare Scope</span> <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="var">Declare</span> <span class="id" title="var">Custom</span> <span class="id" title="var">Entry</span> <span class="id" title="var">com_aux</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="23430cd9e427d30c054d4f029e39cb7f" class="idref" href="#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&quot;</span></a>&lt;{ e }&gt;" := <span class="id" title="var">e</span> (<span class="id" title="var">e</span> <span class="id" title="var">custom</span> <span class="id" title="var">com_aux</span>) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id=":com_aux:com_scope:x" class="idref" href="#:com_aux:com_scope:x"><span class="id" title="notation">&quot;</span></a>e" := <span class="id" title="var">e</span> (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com_aux</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">e</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span>) : <span class="id" title="var">com_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="5a96623d056c293ebbcdf03005796e09" class="idref" href="#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">&quot;</span></a>( x )" := <span class="id" title="var">x</span> (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span>, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id=":com:com_scope:x" class="idref" href="#:com:com_scope:x"><span class="id" title="notation">&quot;</span></a>x" := <span class="id" title="var">x</span> (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="keyword">constr</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0) : <span class="id" title="var">com_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id=":com:com_scope:x_x_'..'_x" class="idref" href="#:com:com_scope:x_x_'..'_x"><span class="id" title="notation">&quot;</span></a>f x .. y" := (.. (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) .. <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="keyword">constr</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="keyword">constr</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">y</span> <span class="id" title="keyword">constr</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 1) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id="ad27fd091d9c8494ce7e5135135d19a8" class="idref" href="#ad27fd091d9c8494ce7e5135135d19a8"><span class="id" title="notation">&quot;</span></a>x + y"   := (<a class="idref" href="PLF.IMP.html#APlus"><span class="id" title="constructor">APlus</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a id=":com::x_'-'_x" class="idref" href="#:com::x_'-'_x"><span class="id" title="notation">&quot;</span></a>x - y"   := (<a class="idref" href="PLF.IMP.html#AMinus"><span class="id" title="constructor">AMinus</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a id="a73c7b35e67094dc8ae672f3a93da066" class="idref" href="#a73c7b35e67094dc8ae672f3a93da066"><span class="id" title="notation">&quot;</span></a>x * y"   := (<a class="idref" href="PLF.IMP.html#AMult"><span class="id" title="constructor">AMult</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a id=":::'true'" class="idref" href="#:::'true'"><span class="id" title="notation">&quot;</span></a>'true'"  := <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 1).<br/>
<span class="id" title="keyword">Notation</span> <a id=":com::'true'" class="idref" href="#:com::'true'"><span class="id" title="notation">&quot;</span></a>'true'"  := <a class="idref" href="PLF.IMP.html#BTrue"><span class="id" title="constructor">BTrue</span></a> (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
<span class="id" title="keyword">Notation</span> <a id=":::'false'" class="idref" href="#:::'false'"><span class="id" title="notation">&quot;</span></a>'false'" := <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 1).<br/>
<span class="id" title="keyword">Notation</span> <a id=":com::'false'" class="idref" href="#:com::'false'"><span class="id" title="notation">&quot;</span></a>'false'" := <a class="idref" href="PLF.IMP.html#BFalse"><span class="id" title="constructor">BFalse</span></a> (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
<span class="id" title="keyword">Notation</span> <a id="d43f15edd52d29ae8e0f90730a25ed5c" class="idref" href="#d43f15edd52d29ae8e0f90730a25ed5c"><span class="id" title="notation">&quot;</span></a>x &lt;= y"  := (<a class="idref" href="PLF.IMP.html#BLe"><span class="id" title="constructor">BLe</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a id=":com::x_'&gt;'_x" class="idref" href="#:com::x_'&gt;'_x"><span class="id" title="notation">&quot;</span></a>x &gt; y"   := (<a class="idref" href="PLF.IMP.html#BGt"><span class="id" title="constructor">BGt</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a id="9e5b22caf5d7cf490e97976162618c2a" class="idref" href="#9e5b22caf5d7cf490e97976162618c2a"><span class="id" title="notation">&quot;</span></a>x = y"   := (<a class="idref" href="PLF.IMP.html#BEq"><span class="id" title="constructor">BEq</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a id=":com::x_'&lt;&gt;'_x" class="idref" href="#:com::x_'&lt;&gt;'_x"><span class="id" title="notation">&quot;</span></a>x &lt;&gt; y"  := (<a class="idref" href="PLF.IMP.html#BNeq"><span class="id" title="constructor">BNeq</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a id=":com::x_'&amp;&amp;'_x" class="idref" href="#:com::x_'&amp;&amp;'_x"><span class="id" title="notation">&quot;</span></a>x &amp;&amp; y"  := (<a class="idref" href="PLF.IMP.html#BAnd"><span class="id" title="constructor">BAnd</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 80, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a id="dfe50505b2b595242030c436d0d7d15f" class="idref" href="#dfe50505b2b595242030c436d0d7d15f"><span class="id" title="notation">&quot;</span></a>'~' b"   := (<a class="idref" href="PLF.IMP.html#BNot"><span class="id" title="constructor">BNot</span></a> <span class="id" title="var">b</span>) (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 75, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>).<br/>

<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">com_scope</span>.<br/>

<br/>
</div>

<div class="doc">
We can now write <span class="inlinecode">3</span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">X</span></span> <span class="inlinecode">×</span> <span class="inlinecode">2)</span> instead  of <span class="inlinecode"><span class="id" title="var">APlus</span></span> <span class="inlinecode">3</span> <span class="inlinecode">(<span class="id" title="var">AMult</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">2)</span>,
    and <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">&amp;&amp;</span> <span class="inlinecode">~(<span class="id" title="var">X</span></span> <span class="inlinecode">≤</span> <span class="inlinecode">4)</span> instead of <span class="inlinecode"><span class="id" title="var">BAnd</span></span> <span class="inlinecode"><span class="id" title="var">true</span></span> <span class="inlinecode">(<span class="id" title="var">BNot</span></span> <span class="inlinecode">(<span class="id" title="var">BLe</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">4))</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="example_aexp" class="idref" href="#example_aexp"><span class="id" title="definition">example_aexp</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a> := <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> 3 <a class="idref" href="PLF.IMP.html#ad27fd091d9c8494ce7e5135135d19a8"><span class="id" title="notation">+</span></a> <a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#a73c7b35e67094dc8ae672f3a93da066"><span class="id" title="notation">×</span></a> 2<a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">)</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a id="example_bexp" class="idref" href="#example_bexp"><span class="id" title="definition">example_bexp</span></a> : <a class="idref" href="PLF.IMP.html#bexp"><span class="id" title="inductive">bexp</span></a> := <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com::'true'"><span class="id" title="notation">true</span></a> <a class="idref" href="PLF.IMP.html#:com::x_'&amp;&amp;'_x"><span class="id" title="notation">&amp;&amp;</span></a> <a class="idref" href="PLF.IMP.html#dfe50505b2b595242030c436d0d7d15f"><span class="id" title="notation">¬</span></a><a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#d43f15edd52d29ae8e0f90730a25ed5c"><span class="id" title="notation">≤</span></a> 4<a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">)</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab145"></a><h2 class="section">Evaluation</h2>

<div class="paragraph"> </div>

 The arith and boolean evaluators must now be extended to
    handle variables in the obvious way, taking a state <span class="inlinecode"><span class="id" title="var">st</span></span> as an
    extra argument: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="aeval" class="idref" href="#aeval"><span class="id" title="definition">aeval</span></a> (<a id="st:24" class="idref" href="#st:24"><span class="id" title="binder">st</span></a> : <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a id="a:25" class="idref" href="#a:25"><span class="id" title="binder">a</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a>) : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="PLF.IMP.html#a:25"><span class="id" title="variable">a</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#ANum"><span class="id" title="constructor">ANum</span></a> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#AId"><span class="id" title="constructor">AId</span></a> <span class="id" title="var">x</span> ⇒ <a class="idref" href="PLF.IMP.html#st:24"><span class="id" title="variable">st</span></a> <span class="id" title="var">x</span>                                <br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><span class="id" title="var">a1</span> <a class="idref" href="PLF.IMP.html#ad27fd091d9c8494ce7e5135135d19a8"><span class="id" title="notation">+</span></a> <span class="id" title="var">a2</span><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒ <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval:26"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:24"><span class="id" title="variable">st</span></a> <span class="id" title="var">a1</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval:26"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:24"><span class="id" title="variable">st</span></a> <span class="id" title="var">a2</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><span class="id" title="var">a1</span> <a class="idref" href="PLF.IMP.html#:com::x_'-'_x"><span class="id" title="notation">-</span></a> <span class="id" title="var">a2</span><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒ <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#::nat_scope:x_'-'_x"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval:26"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:24"><span class="id" title="variable">st</span></a> <span class="id" title="var">a1</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#::nat_scope:x_'-'_x"><span class="id" title="notation">)</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#::nat_scope:x_'-'_x"><span class="id" title="notation">-</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#::nat_scope:x_'-'_x"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval:26"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:24"><span class="id" title="variable">st</span></a> <span class="id" title="var">a2</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#::nat_scope:x_'-'_x"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><span class="id" title="var">a1</span> <a class="idref" href="PLF.IMP.html#a73c7b35e67094dc8ae672f3a93da066"><span class="id" title="notation">×</span></a> <span class="id" title="var">a2</span><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒ <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ea2ff3d561159081cea6fb2e8113cc54"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval:26"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:24"><span class="id" title="variable">st</span></a> <span class="id" title="var">a1</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ea2ff3d561159081cea6fb2e8113cc54"><span class="id" title="notation">)</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ea2ff3d561159081cea6fb2e8113cc54"><span class="id" title="notation">×</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ea2ff3d561159081cea6fb2e8113cc54"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval:26"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:24"><span class="id" title="variable">st</span></a> <span class="id" title="var">a2</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ea2ff3d561159081cea6fb2e8113cc54"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="beval" class="idref" href="#beval"><span class="id" title="definition">beval</span></a> (<a id="st:28" class="idref" href="#st:28"><span class="id" title="binder">st</span></a> : <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a id="b:29" class="idref" href="#b:29"><span class="id" title="binder">b</span></a> : <a class="idref" href="PLF.IMP.html#bexp"><span class="id" title="inductive">bexp</span></a>) : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="PLF.IMP.html#b:29"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><a class="idref" href="PLF.IMP.html#:com::'true'"><span class="id" title="notation">true</span></a><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>      ⇒ <a class="idref" href="PLF.IMP.html#:::'true'"><span class="id" title="notation">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><a class="idref" href="PLF.IMP.html#:com::'false'"><span class="id" title="notation">false</span></a><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>     ⇒ <a class="idref" href="PLF.IMP.html#:::'false'"><span class="id" title="notation">false</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><span class="id" title="var">a1</span> <a class="idref" href="PLF.IMP.html#9e5b22caf5d7cf490e97976162618c2a"><span class="id" title="notation">=</span></a> <span class="id" title="var">a2</span><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>   ⇒ <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">a1</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">=?</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">a2</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><span class="id" title="var">a1</span> <a class="idref" href="PLF.IMP.html#:com::x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> <span class="id" title="var">a2</span><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>  ⇒ <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">a1</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">)</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">=?</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">a2</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#ad2ec4e405f68c46c0a176e3e94ae2e3"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><span class="id" title="var">a1</span> <a class="idref" href="PLF.IMP.html#d43f15edd52d29ae8e0f90730a25ed5c"><span class="id" title="notation">≤</span></a> <span class="id" title="var">a2</span><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>  ⇒ <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">a1</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">)</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">&lt;=?</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">a2</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><span class="id" title="var">a1</span> <a class="idref" href="PLF.IMP.html#:com::x_'&gt;'_x"><span class="id" title="notation">&gt;</span></a> <span class="id" title="var">a2</span><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>   ⇒ <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">a1</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">)</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">&lt;=?</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">a2</span><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0f31f5c1c6b6a21a3a187247222bc9e4"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><a class="idref" href="PLF.IMP.html#dfe50505b2b595242030c436d0d7d15f"><span class="id" title="notation">¬</span></a> <span class="id" title="var">b1</span><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>      ⇒ <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#negb"><span class="id" title="definition">negb</span></a> (<a class="idref" href="PLF.IMP.html#beval:30"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">b1</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a><span class="id" title="var">b1</span> <a class="idref" href="PLF.IMP.html#:com::x_'&amp;&amp;'_x"><span class="id" title="notation">&amp;&amp;</span></a> <span class="id" title="var">b2</span><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>  ⇒ <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#andb"><span class="id" title="definition">andb</span></a> (<a class="idref" href="PLF.IMP.html#beval:30"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">b1</span>) (<a class="idref" href="PLF.IMP.html#beval:30"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st:28"><span class="id" title="variable">st</span></a> <span class="id" title="var">b2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We can use our notation for total maps in the specific case of
    states -- i.e., we write the empty state as <span class="inlinecode">(<span class="id" title="var">_</span></span> <span class="inlinecode">!-&gt;</span> <span class="inlinecode">0)</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="empty_st" class="idref" href="#empty_st"><span class="id" title="definition">empty_st</span></a> := (<a class="idref" href="PLF.Maps.html#b26b31fedd72ecba0f79904d3f161f8b"><span class="id" title="notation">_</span></a> <a class="idref" href="PLF.Maps.html#b26b31fedd72ecba0f79904d3f161f8b"><span class="id" title="notation">!-&gt;</span></a> 0).<br/>

<br/>
</div>

<div class="doc">
Also, we can add a notation for a "singleton state" with just one
    variable bound to a value. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <a id="c78e6ed7f05f8146dc2bcb368255bece" class="idref" href="#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">&quot;</span></a>x '!-&gt;' v" := (<span class="id" title="var">x</span> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> <span class="id" title="var">v</span> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#empty_st"><span class="id" title="definition">empty_st</span></a>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 100, <span class="id" title="var">v</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200).<br/>

<br/>
<span class="id" title="keyword">Example</span> <a id="aexp1" class="idref" href="#aexp1"><span class="id" title="definition">aexp1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> (<a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">!-&gt;</span></a> 5) <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> 3 <a class="idref" href="PLF.IMP.html#ad27fd091d9c8494ce7e5135135d19a8"><span class="id" title="notation">+</span></a> <a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#a73c7b35e67094dc8ae672f3a93da066"><span class="id" title="notation">×</span></a> 2<a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">)</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 13.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">Example</span> <a id="aexp2" class="idref" href="#aexp2"><span class="id" title="definition">aexp2</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> (<a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> 5 <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.IMP.html#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">!-&gt;</span></a> 4) <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#ad27fd091d9c8494ce7e5135135d19a8"><span class="id" title="notation">+</span></a> <a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#a73c7b35e67094dc8ae672f3a93da066"><span class="id" title="notation">×</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a><a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">)</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 20.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <a id="bexp1" class="idref" href="#bexp1"><span class="id" title="definition">bexp1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#beval"><span class="id" title="definition">beval</span></a> (<a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">!-&gt;</span></a> 5) <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com::'true'"><span class="id" title="notation">true</span></a> <a class="idref" href="PLF.IMP.html#:com::x_'&amp;&amp;'_x"><span class="id" title="notation">&amp;&amp;</span></a> <a class="idref" href="PLF.IMP.html#dfe50505b2b595242030c436d0d7d15f"><span class="id" title="notation">¬</span></a><a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#d43f15edd52d29ae8e0f90730a25ed5c"><span class="id" title="notation">≤</span></a> 4<a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">)</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#:::'true'"><span class="id" title="notation">true</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">reflexivity</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab146"></a><h1 class="section">Commands</h1>

<div class="paragraph"> </div>

 Now we are ready to define the syntax and behavior of Imp
    <i>commands</i> (or <i>statements</i>). 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a id="lab147"></a><h2 class="section">Syntax</h2>

<div class="paragraph"> </div>

 Informally, commands <span class="inlinecode"><span class="id" title="var">c</span></span> are described by the following BNF
    grammar.

<div class="paragraph"> </div>

     c := skip
        | x := a
        | c ; c
        | if b then c else c end
        | while b do c end

<div class="paragraph"> </div>

 Here is the formal definition of the abstract syntax of
    commands: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a id="com" class="idref" href="#com"><span class="id" title="definition, inductive"><span id="com_rect" class="id"><span id="com_ind" class="id"><span id="com_rec" class="id"><span id="com_sind" class="id">com</span></span></span></span></span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="CSkip" class="idref" href="#CSkip"><span class="id" title="constructor">CSkip</span></a><br/>
&nbsp;&nbsp;| <a id="CAsgn" class="idref" href="#CAsgn"><span class="id" title="constructor">CAsgn</span></a> (<a id="x:34" class="idref" href="#x:34"><span class="id" title="binder">x</span></a> : <span class="id" title="inductive">string</span>) (<a id="a:35" class="idref" href="#a:35"><span class="id" title="binder">a</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a>)<br/>
&nbsp;&nbsp;| <a id="CSeq" class="idref" href="#CSeq"><span class="id" title="constructor">CSeq</span></a> (<a id="c1:36" class="idref" href="#c1:36"><span class="id" title="binder">c1</span></a> <a id="c2:37" class="idref" href="#c2:37"><span class="id" title="binder">c2</span></a> : <a class="idref" href="PLF.IMP.html#com:32"><span class="id" title="inductive">com</span></a>)<br/>
&nbsp;&nbsp;| <a id="CIf" class="idref" href="#CIf"><span class="id" title="constructor">CIf</span></a> (<a id="b:38" class="idref" href="#b:38"><span class="id" title="binder">b</span></a> : <a class="idref" href="PLF.IMP.html#bexp"><span class="id" title="inductive">bexp</span></a>) (<a id="c1:39" class="idref" href="#c1:39"><span class="id" title="binder">c1</span></a> <a id="c2:40" class="idref" href="#c2:40"><span class="id" title="binder">c2</span></a> : <a class="idref" href="PLF.IMP.html#com:32"><span class="id" title="inductive">com</span></a>)<br/>
&nbsp;&nbsp;| <a id="CWhile" class="idref" href="#CWhile"><span class="id" title="constructor">CWhile</span></a> (<a id="b:41" class="idref" href="#b:41"><span class="id" title="binder">b</span></a> : <a class="idref" href="PLF.IMP.html#bexp"><span class="id" title="inductive">bexp</span></a>) (<a id="c:42" class="idref" href="#c:42"><span class="id" title="binder">c</span></a> : <a class="idref" href="PLF.IMP.html#com:32"><span class="id" title="inductive">com</span></a>).<br/>

<br/>
</div>

<div class="doc">
As we did for expressions, we can use a few <span class="inlinecode"><span class="id" title="keyword">Notation</span></span>
    declarations to make reading and writing Imp programs more
    convenient. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a id=":com:com_scope:'skip'" class="idref" href="#:com:com_scope:'skip'"><span class="id" title="notation">&quot;</span></a>'skip'"  :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#CSkip"><span class="id" title="constructor">CSkip</span></a> (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id="91e9aa710642047a93142bdf557f1a1b" class="idref" href="#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">&quot;</span></a>x := y"  :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PLF.IMP.html#CAsgn"><span class="id" title="constructor">CAsgn</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="keyword">constr</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 85, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id="313afe74ec81f2da17d8e7bca3b042e7" class="idref" href="#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">&quot;</span></a>x ; y" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PLF.IMP.html#CSeq"><span class="id" title="constructor">CSeq</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 90,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id=":com:com_scope:'if'_x_'then'_x_'else'_x_'end'" class="idref" href="#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">&quot;</span></a>'if' x 'then' y 'else' z 'end'" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PLF.IMP.html#CIf"><span class="id" title="constructor">CIf</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 89, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">z</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id=":com:com_scope:'while'_x_'do'_x_'end'" class="idref" href="#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">&quot;</span></a>'while' x 'do' y 'end'" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PLF.IMP.html#CWhile"><span class="id" title="constructor">CWhile</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 89, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99) : <span class="id" title="var">com_scope</span>.<br/>

<br/>
</div>

<div class="doc">
For example, here is the factorial function again, written as a
    formal Coq definition.  When this command terminates, the variable
    <span class="inlinecode"><span class="id" title="var">Y</span></span> will contain the factorial of the initial value of <span class="inlinecode"><span class="id" title="var">X</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="fact_in_coq" class="idref" href="#fact_in_coq"><span class="id" title="definition">fact_in_coq</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a><a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> 1<a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#:com::x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0 <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.IMP.html#a73c7b35e67094dc8ae672f3a93da066"><span class="id" title="notation">×</span></a> <a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a><a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#:com::x_'-'_x"><span class="id" title="notation">-</span></a> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
<a id="lab148"></a><h2 class="section">Desugaring Notations</h2>

<div class="paragraph"> </div>

 Coq offers a rich set of features to manage the increasing
    complexity of the objects we work with, such as coercions and
    notations. However, their heavy usage can make it hard to
    understand what the expressions we enter actually mean. In such
    situations it is often instructive to "turn off" those features to
    get a more elementary picture of things, using the following
    commands:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="keyword">Unset</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Notations</span></span> (undo with <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Notations</span></span>)

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Coercions</span></span> (undo with <span class="inlinecode"><span class="id" title="keyword">Unset</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="var">Coercions</span></span>)

</li>
<li> <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="keyword">All</span></span> (undo with <span class="inlinecode"><span class="id" title="keyword">Unset</span></span> <span class="inlinecode"><span class="id" title="keyword">Printing</span></span> <span class="inlinecode"><span class="id" title="keyword">All</span></span>)

</li>
</ul>

<div class="paragraph"> </div>

    These commands can also be used in the middle of a proof, to
    elaborate the current goal and context. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="keyword">Printing</span> <span class="id" title="var">Notations</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="keyword">Printing</span> <span class="id" title="var">Notations</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Set Printing Coercions</span>.<br/>

<br/>
<span class="id" title="keyword">Unset Printing Coercions</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab149"></a><h2 class="section"><span class="inlinecode"><span class="id" title="keyword">Locate</span></span> Again</h2>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a id="lab150"></a><h3 class="section">Finding identifiers</h3>

<div class="paragraph"> </div>

 When used with an identifier, the <span class="inlinecode"><span class="id" title="keyword">Locate</span></span> prints the full path to
    every value in scope with the same name.  This is useful to
    troubleshoot problems due to variable shadowing. 
</div>
<div class="code">
</div>

<div class="doc">
<a id="lab151"></a><h3 class="section">Finding notations</h3>

<div class="paragraph"> </div>

 When faced with an unknown notation, you can use <span class="inlinecode"><span class="id" title="keyword">Locate</span></span> with a
    string containing one of its symbols to see its possible
    interpretations. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab152"></a><h2 class="section">More Examples</h2>

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a id="lab153"></a><h3 class="section">Assignment:</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="plus2" class="idref" href="#plus2"><span class="id" title="definition">plus2</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#ad27fd091d9c8494ce7e5135135d19a8"><span class="id" title="notation">+</span></a> 2 <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="XtimesYinZ" class="idref" href="#XtimesYinZ"><span class="id" title="definition">XtimesYinZ</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#a73c7b35e67094dc8ae672f3a93da066"><span class="id" title="notation">×</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab154"></a><h3 class="section">Loops</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="subtract_slowly_body" class="idref" href="#subtract_slowly_body"><span class="id" title="definition">subtract_slowly_body</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#:com::x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#:com::x_'-'_x"><span class="id" title="notation">-</span></a> 1 <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="subtract_slowly" class="idref" href="#subtract_slowly"><span class="id" title="definition">subtract_slowly</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#:com::x_'&lt;&gt;'_x"><span class="id" title="notation">≠</span></a> 0 <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#subtract_slowly_body"><span class="id" title="definition">subtract_slowly_body</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="subtract_3_from_5_slowly" class="idref" href="#subtract_3_from_5_slowly"><span class="id" title="definition">subtract_3_from_5_slowly</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> 3 <a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> 5 <a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#subtract_slowly"><span class="id" title="definition">subtract_slowly</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab155"></a><h3 class="section">An infinite loop:</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="loop" class="idref" href="#loop"><span class="id" title="definition">loop</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a> :=<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#:com::'true'"><span class="id" title="notation">true</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:com:com_scope:'skip'"><span class="id" title="notation">skip</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab156"></a><h1 class="section">Evaluating Commands</h1>

<div class="paragraph"> </div>

 Next we need to define what it means to evaluate an Imp command.
    The fact that <span class="inlinecode"><span class="id" title="var">while</span></span> loops don't necessarily terminate makes
    defining an evaluation function tricky... 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a id="lab157"></a><h2 class="section">Evaluation as a Function (Failed Attempt)</h2>

<div class="paragraph"> </div>

 Here's an attempt at defining an evaluation function for commands
    (with a bogus <span class="inlinecode"><span class="id" title="var">while</span></span> case). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="ceval_fun_no_while" class="idref" href="#ceval_fun_no_while"><span class="id" title="definition">ceval_fun_no_while</span></a> (<a id="st:43" class="idref" href="#st:43"><span class="id" title="binder">st</span></a> : <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a>) (<a id="c:44" class="idref" href="#c:44"><span class="id" title="binder">c</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a>) : <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="PLF.IMP.html#c:44"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'skip'"><span class="id" title="notation">skip</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:43"><span class="id" title="variable">st</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <span class="id" title="var">x</span> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <span class="id" title="var">a</span> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">x</span> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> <a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:43"><span class="id" title="variable">st</span></a> <span class="id" title="var">a</span> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#st:43"><span class="id" title="variable">st</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <span class="id" title="var">c1</span> <a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a> <span class="id" title="var">c2</span> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <a id="st':47" class="idref" href="#st':47"><span class="id" title="binder">st'</span></a> := <a class="idref" href="PLF.IMP.html#ceval_fun_no_while:45"><span class="id" title="definition">ceval_fun_no_while</span></a> <a class="idref" href="PLF.IMP.html#st:43"><span class="id" title="variable">st</span></a> <span class="id" title="var">c1</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#ceval_fun_no_while:45"><span class="id" title="definition">ceval_fun_no_while</span></a> <a class="idref" href="PLF.IMP.html#st':47"><span class="id" title="variable">st'</span></a> <span class="id" title="var">c2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">if</span></a> <span class="id" title="var">b</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">then</span></a> <span class="id" title="var">c1</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">else</span></a> <span class="id" title="var">c2</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">end</span></a><a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> (<a class="idref" href="PLF.IMP.html#beval"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st:43"><span class="id" title="variable">st</span></a> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <a class="idref" href="PLF.IMP.html#ceval_fun_no_while:45"><span class="id" title="definition">ceval_fun_no_while</span></a> <a class="idref" href="PLF.IMP.html#st:43"><span class="id" title="variable">st</span></a> <span class="id" title="var">c1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <a class="idref" href="PLF.IMP.html#ceval_fun_no_while:45"><span class="id" title="definition">ceval_fun_no_while</span></a> <a class="idref" href="PLF.IMP.html#st:43"><span class="id" title="variable">st</span></a> <span class="id" title="var">c2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <span class="id" title="var">b</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a> <span class="id" title="var">c</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:43"><span class="id" title="variable">st</span></a>  <br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
In a more conventional functional programming language like OCaml or
    Haskell we could add the <span class="inlinecode"><span class="id" title="var">while</span></span> case as follows:

<div class="paragraph"> </div>

        Fixpoint ceval_fun (st : state) (c : com) : state :=
          match c with
            ...
            | &lt;{ while b do c end}&gt; =&gt;
                if (beval st b)
                  then ceval_fun st &lt;{c ; while b do c end}&gt;
                  else st
          end.

<div class="paragraph"> </div>

    Coq doesn't accept such a definition ("Error: Cannot guess
    decreasing argument of fix") because the function we want to
    define is not guaranteed to terminate. Indeed, it <i>doesn't</i> always
    terminate: for example, the full version of the <span class="inlinecode"><span class="id" title="var">ceval_fun</span></span>
    function applied to the <span class="inlinecode"><span class="id" title="var">loop</span></span> program above would never
    terminate. Since Coq aims to be not just a functional programming
    language but also a consistent logic, any potentially
    non-terminating function needs to be rejected.

<div class="paragraph"> </div>

    Here is an example showing what would go wrong if Coq allowed
    non-terminating recursive functions:

<div class="paragraph"> </div>

         Fixpoint loop_false (n : nat) : False := loop_false n.

<div class="paragraph"> </div>

    That is, propositions like <span class="inlinecode"><span class="id" title="var">False</span></span> would become provable
    (<span class="inlinecode"><span class="id" title="var">loop_false</span></span> <span class="inlinecode">0</span> would be a proof of <span class="inlinecode"><span class="id" title="var">False</span></span>), which would be
    a disaster for Coq's logical consistency.

<div class="paragraph"> </div>

    Thus, because it doesn't terminate on all inputs, <span class="inlinecode"><span class="id" title="var">ceval_fun</span></span>
    cannot be written in Coq -- at least not without additional tricks
    and workarounds (see chapter <span class="inlinecode"><span class="id" title="var">ImpCEvalFun</span></span> if you're curious
    about those). 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a id="lab158"></a><h2 class="section">Evaluation as a Relation</h2>

<div class="paragraph"> </div>

 Here's a better way: define <span class="inlinecode"><span class="id" title="var">ceval</span></span> as a <i>relation</i> rather than a
    <i>function</i> -- i.e., make its result a <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> rather than a
    <span class="inlinecode"><span class="id" title="var">state</span></span>, similar to what we did for <span class="inlinecode"><span class="id" title="var">aevalR</span></span> above. 
<div class="paragraph"> </div>

 This is an important change.  Besides freeing us from awkward
    workarounds, it gives us a ton more flexibility in the definition.
    For example, if we add nondeterministic features like <span class="inlinecode"><span class="id" title="var">any</span></span> to the
    language, we want the definition of evaluation to be
    nondeterministic -- i.e., not only will it not be total, it will
    not even be a function! 
<div class="paragraph"> </div>

 We'll use the notation <span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span> for the <span class="inlinecode"><span class="id" title="var">ceval</span></span> relation:
    <span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span> means that executing program <span class="inlinecode"><span class="id" title="var">c</span></span> in a starting
    state <span class="inlinecode"><span class="id" title="var">st</span></span> results in an ending state <span class="inlinecode"><span class="id" title="var">st'</span></span>.  This can be
    pronounced "<span class="inlinecode"><span class="id" title="var">c</span></span> takes state <span class="inlinecode"><span class="id" title="var">st</span></span> to <span class="inlinecode"><span class="id" title="var">st'</span></span>". 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a id="lab159"></a><h3 class="section">Operational Semantics</h3>

<div class="paragraph"> </div>

 Here is an informal definition of evaluation, presented as inference
    rules for readability:
<hr/>
                            (E_Skip)
                           st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">skip</span></span> <span class="inlinecode"></span>=&gt; st

<div class="paragraph"> </div>

                           aeval st a = n
<hr/>
                      (E_Asgn)
                   st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"></span>=&gt; (x !-&gt; n ; st)

<div class="paragraph"> </div>

                           st  =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"></span>=&gt; st'
                           st' =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"></span>=&gt; st''
<hr/>
                           (E_Seq)
                         st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c1</span>;<span class="id" title="var">c2</span></span> <span class="inlinecode"></span>=&gt; st''

<div class="paragraph"> </div>

                          beval st b = true
                           st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"></span>=&gt; st'
<hr/>
               (E_IfTrue)
                st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span> <span class="inlinecode"></span>=&gt; st'

<div class="paragraph"> </div>

                         beval st b = false
                           st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"></span>=&gt; st'
<hr/>
              (E_IfFalse)
                st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span> <span class="inlinecode"></span>=&gt; st'

<div class="paragraph"> </div>

                         beval st b = false
<hr/>
                 (E_WhileFalse)
                    st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">while</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="tactic">do</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span> <span class="inlinecode"></span>=&gt; st

<div class="paragraph"> </div>

                          beval st b = true
                           st =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"></span>=&gt; st'
                  st' =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">while</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="tactic">do</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span> <span class="inlinecode"></span>=&gt; st''
<hr/>
                 (E_WhileTrue)
                  st  =<span class="inlinecode"></span> <span class="inlinecode"><span class="id" title="var">while</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="tactic">do</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span> <span class="inlinecode"></span>=&gt; st''

<div class="paragraph"> </div>

 Here is the formal definition.  Make sure you understand
    how it corresponds to the inference rules. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Reserved Notation</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"st '=[' c ']=&gt;' st'"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="var">c</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">st</span> <span class="id" title="keyword">constr</span>, <span class="id" title="var">st'</span> <span class="id" title="keyword">constr</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>).<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <a id="ceval" class="idref" href="#ceval"><span class="id" title="definition, inductive"><span id="ceval_ind" class="id"><span id="ceval_sind" class="id">ceval</span></span></span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a id="E_Skip" class="idref" href="#E_Skip"><span class="id" title="constructor">E_Skip</span></a> : <span class="id" title="keyword">∀</span> <a id="st:50" class="idref" href="#st:50"><span class="id" title="binder">st</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:50"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'skip'"><span class="id" title="notation">skip</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st:50"><span class="id" title="variable">st</span></a><br/>
&nbsp;&nbsp;| <a id="E_Asgn" class="idref" href="#E_Asgn"><span class="id" title="constructor">E_Asgn</span></a>  : <span class="id" title="keyword">∀</span> <a id="st:51" class="idref" href="#st:51"><span class="id" title="binder">st</span></a> <a id="a:52" class="idref" href="#a:52"><span class="id" title="binder">a</span></a> <a id="n:53" class="idref" href="#n:53"><span class="id" title="binder">n</span></a> <a id="x:54" class="idref" href="#x:54"><span class="id" title="binder">x</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:51"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#a:52"><span class="id" title="variable">a</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#n:53"><span class="id" title="variable">n</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:51"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#x:54"><span class="id" title="variable">x</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <a class="idref" href="PLF.IMP.html#a:52"><span class="id" title="variable">a</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#x:54"><span class="id" title="variable">x</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> <a class="idref" href="PLF.IMP.html#n:53"><span class="id" title="variable">n</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#st:51"><span class="id" title="variable">st</span></a><a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;| <a id="E_Seq" class="idref" href="#E_Seq"><span class="id" title="constructor">E_Seq</span></a> : <span class="id" title="keyword">∀</span> <a id="c1:55" class="idref" href="#c1:55"><span class="id" title="binder">c1</span></a> <a id="c2:56" class="idref" href="#c2:56"><span class="id" title="binder">c2</span></a> <a id="st:57" class="idref" href="#st:57"><span class="id" title="binder">st</span></a> <a id="st':58" class="idref" href="#st':58"><span class="id" title="binder">st'</span></a> <a id="st'':59" class="idref" href="#st'':59"><span class="id" title="binder">st''</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:57"><span class="id" title="variable">st</span></a>  <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c1:55"><span class="id" title="variable">c1</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':58"><span class="id" title="variable">st'</span></a>  <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st':58"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c2:56"><span class="id" title="variable">c2</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st'':59"><span class="id" title="variable">st''</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:57"><span class="id" title="variable">st</span></a>  <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c1:55"><span class="id" title="variable">c1</span></a> <a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#c2:56"><span class="id" title="variable">c2</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st'':59"><span class="id" title="variable">st''</span></a><br/>
&nbsp;&nbsp;| <a id="E_IfTrue" class="idref" href="#E_IfTrue"><span class="id" title="constructor">E_IfTrue</span></a> : <span class="id" title="keyword">∀</span> <a id="st:60" class="idref" href="#st:60"><span class="id" title="binder">st</span></a> <a id="st':61" class="idref" href="#st':61"><span class="id" title="binder">st'</span></a> <a id="b:62" class="idref" href="#b:62"><span class="id" title="binder">b</span></a> <a id="c1:63" class="idref" href="#c1:63"><span class="id" title="binder">c1</span></a> <a id="c2:64" class="idref" href="#c2:64"><span class="id" title="binder">c2</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#beval"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st:60"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#b:62"><span class="id" title="variable">b</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#:::'true'"><span class="id" title="notation">true</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:60"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c1:63"><span class="id" title="variable">c1</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':61"><span class="id" title="variable">st'</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:60"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">if</span></a> <a class="idref" href="PLF.IMP.html#b:62"><span class="id" title="variable">b</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">then</span></a> <a class="idref" href="PLF.IMP.html#c1:63"><span class="id" title="variable">c1</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">else</span></a> <a class="idref" href="PLF.IMP.html#c2:64"><span class="id" title="variable">c2</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">end</span></a><a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':61"><span class="id" title="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a id="E_IfFalse" class="idref" href="#E_IfFalse"><span class="id" title="constructor">E_IfFalse</span></a> : <span class="id" title="keyword">∀</span> <a id="st:65" class="idref" href="#st:65"><span class="id" title="binder">st</span></a> <a id="st':66" class="idref" href="#st':66"><span class="id" title="binder">st'</span></a> <a id="b:67" class="idref" href="#b:67"><span class="id" title="binder">b</span></a> <a id="c1:68" class="idref" href="#c1:68"><span class="id" title="binder">c1</span></a> <a id="c2:69" class="idref" href="#c2:69"><span class="id" title="binder">c2</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#beval"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st:65"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#b:67"><span class="id" title="variable">b</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#:::'false'"><span class="id" title="notation">false</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:65"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c2:69"><span class="id" title="variable">c2</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':66"><span class="id" title="variable">st'</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:65"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">if</span></a> <a class="idref" href="PLF.IMP.html#b:67"><span class="id" title="variable">b</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">then</span></a> <a class="idref" href="PLF.IMP.html#c1:68"><span class="id" title="variable">c1</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">else</span></a> <a class="idref" href="PLF.IMP.html#c2:69"><span class="id" title="variable">c2</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">end</span></a><a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':66"><span class="id" title="variable">st'</span></a><br/>
&nbsp;&nbsp;| <a id="E_WhileFalse" class="idref" href="#E_WhileFalse"><span class="id" title="constructor">E_WhileFalse</span></a> : <span class="id" title="keyword">∀</span> <a id="b:70" class="idref" href="#b:70"><span class="id" title="binder">b</span></a> <a id="st:71" class="idref" href="#st:71"><span class="id" title="binder">st</span></a> <a id="c:72" class="idref" href="#c:72"><span class="id" title="binder">c</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#beval"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st:71"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#b:70"><span class="id" title="variable">b</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#:::'false'"><span class="id" title="notation">false</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:71"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#b:70"><span class="id" title="variable">b</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a> <a class="idref" href="PLF.IMP.html#c:72"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st:71"><span class="id" title="variable">st</span></a><br/>
&nbsp;&nbsp;| <a id="E_WhileTrue" class="idref" href="#E_WhileTrue"><span class="id" title="constructor">E_WhileTrue</span></a> : <span class="id" title="keyword">∀</span> <a id="st:73" class="idref" href="#st:73"><span class="id" title="binder">st</span></a> <a id="st':74" class="idref" href="#st':74"><span class="id" title="binder">st'</span></a> <a id="st'':75" class="idref" href="#st'':75"><span class="id" title="binder">st''</span></a> <a id="b:76" class="idref" href="#b:76"><span class="id" title="binder">b</span></a> <a id="c:77" class="idref" href="#c:77"><span class="id" title="binder">c</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#beval"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st:73"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#b:76"><span class="id" title="variable">b</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#:::'true'"><span class="id" title="notation">true</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:73"><span class="id" title="variable">st</span></a>  <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c:77"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':74"><span class="id" title="variable">st'</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st':74"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#b:76"><span class="id" title="variable">b</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a> <a class="idref" href="PLF.IMP.html#c:77"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st'':75"><span class="id" title="variable">st''</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:73"><span class="id" title="variable">st</span></a>  <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#b:76"><span class="id" title="variable">b</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a> <a class="idref" href="PLF.IMP.html#c:77"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st'':75"><span class="id" title="variable">st''</span></a><br/>
<br/>
&nbsp;&nbsp;<span class="id" title="keyword">where</span> <a id="6037d1f4787d63984beccd5510872ee9" class="idref" href="#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">&quot;</span></a>st =[ c ]=&gt; st'" := (<a class="idref" href="PLF.IMP.html#ceval:49"><span class="id" title="inductive">ceval</span></a> <span class="id" title="var">c</span> <span class="id" title="var">st</span> <span class="id" title="var">st'</span>).<br/>

<br/>
</div>

<div class="doc">
The cost of defining evaluation as a relation instead of a
    function is that we now need to construct a <i>proof</i> that some
    program evaluates to some result state, rather than just letting
    Coq's computation mechanism do it for us. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <a id="ceval_example1" class="idref" href="#ceval_example1"><span class="id" title="definition">ceval_example1</span></a>:<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#empty_st"><span class="id" title="definition">empty_st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> 2<a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">if</span></a> <a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#d43f15edd52d29ae8e0f90730a25ed5c"><span class="id" title="notation">≤</span></a> 1<a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">)</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">then</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> 3<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">else</span></a> <a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> 4<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">end</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> 4 <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">!-&gt;</span></a> 2<a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="PLF.IMP.html#E_Seq"><span class="id" title="constructor">E_Seq</span></a> <span class="id" title="keyword">with</span> (<a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">!-&gt;</span></a> 2).<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="PLF.IMP.html#E_Asgn"><span class="id" title="constructor">E_Asgn</span></a>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="PLF.IMP.html#E_IfFalse"><span class="id" title="constructor">E_IfFalse</span></a>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <a class="idref" href="PLF.IMP.html#E_Asgn"><span class="id" title="constructor">E_Asgn</span></a>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab160"></a><h4 class="section">Exercise: 2 stars, standard (ceval_example2)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Example</span> <a id="ceval_example2" class="idref" href="#ceval_example2"><span class="id" title="definition">ceval_example2</span></a>:<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#empty_st"><span class="id" title="definition">empty_st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> 0<a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> 1<a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> 2<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#Z"><span class="id" title="definition">Z</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> 2 <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> 1 <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">!-&gt;</span></a> 0<a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="keyword">Printing</span> <span class="id" title="keyword">Implicit</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab161"></a><h4 class="section">Exercise: 3 stars, standard, optional (pup_to_n)</h4>


<div class="paragraph"> </div>

    Write an Imp program that sums the numbers from <span class="inlinecode">1</span> to <span class="inlinecode"><span class="id" title="var">X</span></span>
    (inclusive: <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">...</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">X</span></span>) in the variable <span class="inlinecode"><span class="id" title="var">Y</span></span>.  Your program
    should update the state as shown in theorem <span class="inlinecode"><span class="id" title="var">pup_to_2_ceval</span></span>,
    which you can reverse-engineer to discover the program you should
    write.  The proof of that theorem will be somewhat lengthy. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a id="pup_to_n" class="idref" href="#pup_to_n"><span class="id" title="definition">pup_to_n</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="pup_to_2_ceval" class="idref" href="#pup_to_2_ceval"><span class="id" title="lemma">pup_to_2_ceval</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">!-&gt;</span></a> 2<a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">)</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#pup_to_n"><span class="id" title="axiom">pup_to_n</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">(</span></a><a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> 0 <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> 3 <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> 1 <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> 2 <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a> <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">!-&gt;</span></a> 0 <a class="idref" href="PLF.Maps.html#630986d105c0f1782d085b9a306379a7"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">!-&gt;</span></a> 2<a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a id="lab162"></a><h2 class="section">Determinism of Evaluation</h2>

<div class="paragraph"> </div>

 Changing from a computational to a relational definition of
    evaluation is a good move because it frees us from the artificial
    requirement that evaluation should be a total function.  But it
    also raises a question: Is the second definition of evaluation
    really a partial <i>function</i>?  Or is it possible that, beginning from
    the same state <span class="inlinecode"><span class="id" title="var">st</span></span>, we could evaluate some command <span class="inlinecode"><span class="id" title="var">c</span></span> in
    different ways to reach two different output states <span class="inlinecode"><span class="id" title="var">st'</span></span> and
    <span class="inlinecode"><span class="id" title="var">st''</span></span>?

<div class="paragraph"> </div>

    In fact, this cannot happen: <span class="inlinecode"><span class="id" title="var">ceval</span></span> <i>is</i> a partial function: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="ceval_deterministic" class="idref" href="#ceval_deterministic"><span class="id" title="lemma">ceval_deterministic</span></a>: <span class="id" title="keyword">∀</span> <a id="c:78" class="idref" href="#c:78"><span class="id" title="binder">c</span></a> <a id="st:79" class="idref" href="#st:79"><span class="id" title="binder">st</span></a> <a id="st1:80" class="idref" href="#st1:80"><span class="id" title="binder">st1</span></a> <a id="st2:81" class="idref" href="#st2:81"><span class="id" title="binder">st2</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:79"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c:78"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st1:80"><span class="id" title="variable">st1</span></a>  <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:79"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c:78"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st2:81"><span class="id" title="variable">st2</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st1:80"><span class="id" title="variable">st1</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#st2:81"><span class="id" title="variable">st2</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">c</span> <span class="id" title="var">st</span> <span class="id" title="var">st1</span> <span class="id" title="var">st2</span> <span class="id" title="var">E1</span> <span class="id" title="var">E2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">generalize</span> <span class="id" title="tactic">dependent</span> <span class="id" title="var">st2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">E1</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">st2</span> <span class="id" title="var">E2</span>; <span class="id" title="tactic">inversion</span> <span class="id" title="var">E2</span>; <span class="id" title="tactic">subst</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;-  <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">IHE1_1</span> <span class="id" title="var">st'0</span> <span class="id" title="var">H1</span>) <span class="id" title="tactic">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHE1_2</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHE1</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H5</span>. <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H5</span>. <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHE1</span>. <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H2</span>. <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H4</span>. <span class="id" title="tactic">discriminate</span>.<br/>
&nbsp;&nbsp;- <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">IHE1_1</span> <span class="id" title="var">st'0</span> <span class="id" title="var">H3</span>) <span class="id" title="tactic">in</span> ×.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHE1_2</span>. <span class="id" title="tactic">assumption</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab163"></a><h1 class="section">Reasoning About Imp Programs</h1>

<div class="paragraph"> </div>

 We'll get into more systematic and powerful techniques for
    reasoning about Imp programs in <i>Programming Language
    Foundations</i>, but we can already do a few things (albeit in a
    somewhat low-level way) just by working with the bare definitions.
    This section explores some examples. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="plus2_spec" class="idref" href="#plus2_spec"><span class="id" title="lemma">plus2_spec</span></a> : <span class="id" title="keyword">∀</span> <a id="st:82" class="idref" href="#st:82"><span class="id" title="binder">st</span></a> <a id="n:83" class="idref" href="#n:83"><span class="id" title="binder">n</span></a> <a id="st':84" class="idref" href="#st':84"><span class="id" title="binder">st'</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:82"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#n:83"><span class="id" title="variable">n</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:82"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#plus2"><span class="id" title="definition">plus2</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':84"><span class="id" title="variable">st'</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st':84"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#n:83"><span class="id" title="variable">n</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Nat.html#0dacc1786c5ba797d47dd85006231633"><span class="id" title="notation">+</span></a> 2.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">st</span> <span class="id" title="var">n</span> <span class="id" title="var">st'</span> <span class="id" title="var">HX</span> <span class="id" title="var">Heval</span>.<br/>

<br/>
</div>

<div class="doc">
Inverting <span class="inlinecode"><span class="id" title="var">Heval</span></span> essentially forces Coq to expand one step of
      the <span class="inlinecode"><span class="id" title="var">ceval</span></span> computation -- in this case revealing that <span class="inlinecode"><span class="id" title="var">st'</span></span>
      must be <span class="inlinecode"><span class="id" title="var">st</span></span> extended with the new value of <span class="inlinecode"><span class="id" title="var">X</span></span>, since <span class="inlinecode"><span class="id" title="var">plus2</span></span>
      is an assignment. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">inversion</span> <span class="id" title="var">Heval</span>. <span class="id" title="tactic">subst</span>. <span class="id" title="tactic">clear</span> <span class="id" title="var">Heval</span>. <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <a class="idref" href="PLF.Maps.html#t_update_eq"><span class="id" title="axiom">t_update_eq</span></a>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab164"></a><h4 class="section">Exercise: 3 stars, standard, optional (XtimesYinZ_spec)</h4>


<div class="paragraph"> </div>

    State and prove a specification of <span class="inlinecode"><span class="id" title="var">XtimesYinZ</span></span>. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="manual_grade_for_XtimesYinZ_spec" class="idref" href="#manual_grade_for_XtimesYinZ_spec"><span class="id" title="definition">manual_grade_for_XtimesYinZ_spec</span></a> : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> (<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><span class="id" title="inductive">string</span>) := <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a id="lab165"></a><h4 class="section">Exercise: 3 stars, standard, especially useful (loop_never_stops)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a id="loop_never_stops" class="idref" href="#loop_never_stops"><span class="id" title="lemma">loop_never_stops</span></a> : <span class="id" title="keyword">∀</span> <a id="st:85" class="idref" href="#st:85"><span class="id" title="binder">st</span></a> <a id="st':86" class="idref" href="#st':86"><span class="id" title="binder">st'</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~(</span></a><a class="idref" href="PLF.IMP.html#st:85"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#loop"><span class="id" title="definition">loop</span></a> <a class="idref" href="PLF.IMP.html#6037d1f4787d63984beccd5510872ee9"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':86"><span class="id" title="variable">st'</span></a><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">st</span> <span class="id" title="var">st'</span> <span class="id" title="var">contra</span>. <span class="id" title="tactic">unfold</span> <a class="idref" href="PLF.IMP.html#loop"><span class="id" title="definition">loop</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">contra</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">remember</span> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#:com::'true'"><span class="id" title="notation">true</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'skip'"><span class="id" title="notation">skip</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> <span class="id" title="keyword">as</span> <span class="id" title="var">loopdef</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eqn</span>:<span class="id" title="var">Heqloopdef</span>.<br/>

<br/>
</div>

<div class="doc">
Proceed by induction on the assumed derivation showing that
      <span class="inlinecode"><span class="id" title="var">loopdef</span></span> terminates.  Most of the cases are immediately
      contradictory and so can be solved in one step with
      <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>. 
</div>
<div class="code">

<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a id="lab166"></a><h4 class="section">Exercise: 3 stars, standard (no_whiles_eqv)</h4>


<div class="paragraph"> </div>

    Consider the following function: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="no_whiles" class="idref" href="#no_whiles"><span class="id" title="definition">no_whiles</span></a> (<a id="c:87" class="idref" href="#c:87"><span class="id" title="binder">c</span></a> : <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a>) : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="PLF.IMP.html#c:87"><span class="id" title="variable">c</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'skip'"><span class="id" title="notation">skip</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:::'true'"><span class="id" title="notation">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <span class="id" title="var">_</span> <a class="idref" href="PLF.IMP.html#91e9aa710642047a93142bdf557f1a1b"><span class="id" title="notation">:=</span></a> <span class="id" title="var">_</span> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:::'true'"><span class="id" title="notation">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <span class="id" title="var">c1</span> <a class="idref" href="PLF.IMP.html#313afe74ec81f2da17d8e7bca3b042e7"><span class="id" title="notation">;</span></a> <span class="id" title="var">c2</span> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#andb"><span class="id" title="definition">andb</span></a> (<a class="idref" href="PLF.IMP.html#no_whiles:88"><span class="id" title="definition">no_whiles</span></a> <span class="id" title="var">c1</span>) (<a class="idref" href="PLF.IMP.html#no_whiles:88"><span class="id" title="definition">no_whiles</span></a> <span class="id" title="var">c2</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">if</span></a> <span class="id" title="var">_</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">then</span></a> <span class="id" title="var">ct</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">else</span></a> <span class="id" title="var">cf</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#andb"><span class="id" title="definition">andb</span></a> (<a class="idref" href="PLF.IMP.html#no_whiles:88"><span class="id" title="definition">no_whiles</span></a> <span class="id" title="var">ct</span>) (<a class="idref" href="PLF.IMP.html#no_whiles:88"><span class="id" title="definition">no_whiles</span></a> <span class="id" title="var">cf</span>)<br/>
&nbsp;&nbsp;| <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <span class="id" title="var">_</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a> <span class="id" title="var">_</span> <a class="idref" href="PLF.IMP.html#:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a>  ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#:::'false'"><span class="id" title="notation">false</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
This predicate yields <span class="inlinecode"><span class="id" title="var">true</span></span> just on programs that have no while
    loops.  Using <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span>, write a property <span class="inlinecode"><span class="id" title="var">no_whilesR</span></span> such that
    <span class="inlinecode"><span class="id" title="var">no_whilesR</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> is provable exactly when <span class="inlinecode"><span class="id" title="var">c</span></span> is a program with no
    while loops.  Then prove its equivalence with <span class="inlinecode"><span class="id" title="var">no_whiles</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a id="no_whilesR" class="idref" href="#no_whilesR"><span class="id" title="definition, inductive"><span id="no_whilesR_rect" class="id"><span id="no_whilesR_ind" class="id"><span id="no_whilesR_rec" class="id"><span id="no_whilesR_sind" class="id">no_whilesR</span></span></span></span></span></a>: <a class="idref" href="PLF.IMP.html#com"><span class="id" title="inductive">com</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;<br/>
.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="no_whiles_eqv" class="idref" href="#no_whiles_eqv"><span class="id" title="lemma">no_whiles_eqv</span></a>:<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a id="c:92" class="idref" href="#c:92"><span class="id" title="binder">c</span></a>, <a class="idref" href="PLF.IMP.html#no_whiles"><span class="id" title="definition">no_whiles</span></a> <a class="idref" href="PLF.IMP.html#c:92"><span class="id" title="variable">c</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#:::'true'"><span class="id" title="notation">true</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'&lt;-&gt;'_x"><span class="id" title="notation">↔</span></a> <a class="idref" href="PLF.IMP.html#no_whilesR"><span class="id" title="inductive">no_whilesR</span></a> <a class="idref" href="PLF.IMP.html#c:92"><span class="id" title="variable">c</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a id="lab167"></a><h4 class="section">Exercise: 4 stars, standard (no_whiles_terminating)</h4>


<div class="paragraph"> </div>

    Imp programs that don't involve while loops always terminate.
    State and prove a theorem <span class="inlinecode"><span class="id" title="var">no_whiles_terminating</span></span> that says this.

<div class="paragraph"> </div>

    Use either <span class="inlinecode"><span class="id" title="var">no_whiles</span></span> or <span class="inlinecode"><span class="id" title="var">no_whilesR</span></span>, as you prefer. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a id="manual_grade_for_no_whiles_terminating" class="idref" href="#manual_grade_for_no_whiles_terminating"><span class="id" title="definition">manual_grade_for_no_whiles_terminating</span></a> : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> (<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#11c698c8685bb8ab1cf725545c085ac4"><span class="id" title="notation">×</span></a><span class="id" title="inductive">string</span>) := <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a id="lab168"></a><h1 class="section">Additional Exercises</h1>

<div class="paragraph"> </div>

<a id="lab169"></a><h4 class="section">Exercise: 3 stars, standard (stack_compiler)</h4>


<div class="paragraph"> </div>

    Old HP Calculators, programming languages like Forth and Postscript,
    and abstract machines like the Java Virtual Machine all evaluate
    arithmetic expressions using a <i>stack</i>. For instance, the expression

<div class="paragraph"> </div>

      (2*3)+(3*(4-2))

<div class="paragraph"> </div>

   would be written as

<div class="paragraph"> </div>

      2 3 * 3 4 2 - * +

<div class="paragraph"> </div>

   and evaluated like this (where we show the program being evaluated
   on the right and the contents of the stack on the left):

<div class="paragraph"> </div>

      <span class="inlinecode"></span> <span class="inlinecode"></span>           |    2 3 * 3 4 2 - * +
      <span class="inlinecode">2</span>           |    3 * 3 4 2 - * +
      <span class="inlinecode">3,</span> <span class="inlinecode">2</span>        |    * 3 4 2 - * +
      <span class="inlinecode">6</span>           |    3 4 2 - * +
      <span class="inlinecode">3,</span> <span class="inlinecode">6</span>        |    4 2 - * +
      <span class="inlinecode">4,</span> <span class="inlinecode">3,</span> <span class="inlinecode">6</span>     |    2 - * +
      <span class="inlinecode">2,</span> <span class="inlinecode">4,</span> <span class="inlinecode">3,</span> <span class="inlinecode">6</span>  |    - * +
      <span class="inlinecode">2,</span> <span class="inlinecode">3,</span> <span class="inlinecode">6</span>     |    * +
      <span class="inlinecode">6,</span> <span class="inlinecode">6</span>        |    +
      <span class="inlinecode">12</span>          |

<div class="paragraph"> </div>

  The goal of this exercise is to write a small compiler that
  translates <span class="inlinecode"><span class="id" title="var">aexp</span></span>s into stack machine instructions.

<div class="paragraph"> </div>

  The instruction set for our stack language will consist of the
  following instructions:
<ul class="doclist">
<li> <span class="inlinecode"><span class="id" title="var">SPush</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>: Push the number <span class="inlinecode"><span class="id" title="var">n</span></span> on the stack.

</li>
<li> <span class="inlinecode"><span class="id" title="var">SLoad</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>: Load the identifier <span class="inlinecode"><span class="id" title="var">x</span></span> from the store and push it
                  on the stack

</li>
<li> <span class="inlinecode"><span class="id" title="var">SPlus</span></span>:   Pop the two top numbers from the stack, add them, and
                  push the result onto the stack.

</li>
<li> <span class="inlinecode"><span class="id" title="var">SMinus</span></span>:  Similar, but subtract the first number from the second.

</li>
<li> <span class="inlinecode"><span class="id" title="var">SMult</span></span>:   Similar, but multiply. 

</li>
</ul>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a id="sinstr" class="idref" href="#sinstr"><span class="id" title="definition, inductive"><span id="sinstr_rect" class="id"><span id="sinstr_ind" class="id"><span id="sinstr_rec" class="id"><span id="sinstr_sind" class="id">sinstr</span></span></span></span></span></a> : <span class="id" title="keyword">Type</span> :=<br/>
| <a id="SPush" class="idref" href="#SPush"><span class="id" title="constructor">SPush</span></a> (<a id="n:95" class="idref" href="#n:95"><span class="id" title="binder">n</span></a> : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
| <a id="SLoad" class="idref" href="#SLoad"><span class="id" title="constructor">SLoad</span></a> (<a id="x:96" class="idref" href="#x:96"><span class="id" title="binder">x</span></a> : <span class="id" title="inductive">string</span>)<br/>
| <a id="SPlus" class="idref" href="#SPlus"><span class="id" title="constructor">SPlus</span></a><br/>
| <a id="SMinus" class="idref" href="#SMinus"><span class="id" title="constructor">SMinus</span></a><br/>
| <a id="SMult" class="idref" href="#SMult"><span class="id" title="constructor">SMult</span></a>.<br/>

<br/>
</div>

<div class="doc">
Write a function to evaluate programs in the stack language. It
    should take as input a state, a stack represented as a list of
    numbers (top stack item is the head of the list), and a program
    represented as a list of instructions, and it should return the
    stack after executing the program.  Test your function on the
    examples below.

<div class="paragraph"> </div>

    Note that it is unspecified what to do when encountering an
    <span class="inlinecode"><span class="id" title="var">SPlus</span></span>, <span class="inlinecode"><span class="id" title="var">SMinus</span></span>, or <span class="inlinecode"><span class="id" title="var">SMult</span></span> instruction if the stack contains
    fewer than two elements.  In a sense, it is immaterial what we do,
    since a correct compiler will never emit such a malformed program.
    But for sake of later exercises, it would be best to skip the
    offending instruction and continue with the next one.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="s_execute" class="idref" href="#s_execute"><span class="id" title="definition">s_execute</span></a> (<a id="st:97" class="idref" href="#st:97"><span class="id" title="binder">st</span></a> : <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a>) (<a id="stack:98" class="idref" href="#stack:98"><span class="id" title="binder">stack</span></a> : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a id="prog:99" class="idref" href="#prog:99"><span class="id" title="binder">prog</span></a> : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="PLF.IMP.html#sinstr"><span class="id" title="inductive">sinstr</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Example</span> <a id="s_execute1" class="idref" href="#s_execute1"><span class="id" title="definition">s_execute1</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#s_execute"><span class="id" title="axiom">s_execute</span></a> <a class="idref" href="PLF.IMP.html#empty_st"><span class="id" title="definition">empty_st</span></a> <span class="id" title="notation">[]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">[</span><a class="idref" href="PLF.IMP.html#SPush"><span class="id" title="constructor">SPush</span></a> 5<span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SPush"><span class="id" title="constructor">SPush</span></a> 3<span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SPush"><span class="id" title="constructor">SPush</span></a> 1<span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SMinus"><span class="id" title="constructor">SMinus</span></a><span class="id" title="notation">]</span><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="notation">[</span>2<span class="id" title="notation">;</span> 5<span class="id" title="notation">]</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Example</span> <a id="s_execute2" class="idref" href="#s_execute2"><span class="id" title="definition">s_execute2</span></a> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#s_execute"><span class="id" title="axiom">s_execute</span></a> (<a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#c78e6ed7f05f8146dc2bcb368255bece"><span class="id" title="notation">!-&gt;</span></a> 3) <span class="id" title="notation">[</span>3<span class="id" title="notation">;</span>4<span class="id" title="notation">]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">[</span><a class="idref" href="PLF.IMP.html#SPush"><span class="id" title="constructor">SPush</span></a> 4<span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SLoad"><span class="id" title="constructor">SLoad</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a><span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SMult"><span class="id" title="constructor">SMult</span></a><span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SPlus"><span class="id" title="constructor">SPlus</span></a><span class="id" title="notation">]</span><br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="notation">[</span>15<span class="id" title="notation">;</span> 4<span class="id" title="notation">]</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
Next, write a function that compiles an <span class="inlinecode"><span class="id" title="var">aexp</span></span> into a stack
    machine program. The effect of running the program should be the
    same as pushing the value of the expression on the stack. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a id="s_compile" class="idref" href="#s_compile"><span class="id" title="definition">s_compile</span></a> (<a id="e:101" class="idref" href="#e:101"><span class="id" title="binder">e</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a>) : <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="PLF.IMP.html#sinstr"><span class="id" title="inductive">sinstr</span></a><br/>
&nbsp;&nbsp;. <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
After you've defined <span class="inlinecode"><span class="id" title="var">s_compile</span></span>, prove the following to test
    that it works. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <a id="s_compile1" class="idref" href="#s_compile1"><span class="id" title="definition">s_compile1</span></a> :<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#s_compile"><span class="id" title="axiom">s_compile</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">&lt;{</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a> <a class="idref" href="PLF.IMP.html#:com::x_'-'_x"><span class="id" title="notation">-</span></a> <a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">(</span></a>2 <a class="idref" href="PLF.IMP.html#a73c7b35e67094dc8ae672f3a93da066"><span class="id" title="notation">×</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a><a class="idref" href="PLF.IMP.html#5a96623d056c293ebbcdf03005796e09"><span class="id" title="notation">)</span></a> <a class="idref" href="PLF.IMP.html#23430cd9e427d30c054d4f029e39cb7f"><span class="id" title="notation">}&gt;</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="notation">[</span><a class="idref" href="PLF.IMP.html#SLoad"><span class="id" title="constructor">SLoad</span></a> <a class="idref" href="PLF.IMP.html#X"><span class="id" title="definition">X</span></a><span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SPush"><span class="id" title="constructor">SPush</span></a> 2<span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SLoad"><span class="id" title="constructor">SLoad</span></a> <a class="idref" href="PLF.IMP.html#Y"><span class="id" title="definition">Y</span></a><span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SMult"><span class="id" title="constructor">SMult</span></a><span class="id" title="notation">;</span> <a class="idref" href="PLF.IMP.html#SMinus"><span class="id" title="constructor">SMinus</span></a><span class="id" title="notation">]</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a id="lab170"></a><h4 class="section">Exercise: 3 stars, standard (execute_app)</h4>

<div class="paragraph"> </div>

 Execution can be decomposed in the following sense: executing
    stack program <span class="inlinecode"><span class="id" title="var">p1</span></span> <span class="inlinecode">++</span> <span class="inlinecode"><span class="id" title="var">p2</span></span> is the same as executing <span class="inlinecode"><span class="id" title="var">p1</span></span>, taking
    the resulting stack, and executing <span class="inlinecode"><span class="id" title="var">p2</span></span> from that stack. Prove
    that fact. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="execute_app" class="idref" href="#execute_app"><span class="id" title="lemma">execute_app</span></a> : <span class="id" title="keyword">∀</span> <a id="st:103" class="idref" href="#st:103"><span class="id" title="binder">st</span></a> <a id="p1:104" class="idref" href="#p1:104"><span class="id" title="binder">p1</span></a> <a id="p2:105" class="idref" href="#p2:105"><span class="id" title="binder">p2</span></a> <a id="stack:106" class="idref" href="#stack:106"><span class="id" title="binder">stack</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#s_execute"><span class="id" title="axiom">s_execute</span></a> <a class="idref" href="PLF.IMP.html#st:103"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#stack:106"><span class="id" title="variable">stack</span></a> (<a class="idref" href="PLF.IMP.html#p1:104"><span class="id" title="variable">p1</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#bc347c51eaf667706ae54503b26d52c6"><span class="id" title="notation">++</span></a> <a class="idref" href="PLF.IMP.html#p2:105"><span class="id" title="variable">p2</span></a>) <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#s_execute"><span class="id" title="axiom">s_execute</span></a> <a class="idref" href="PLF.IMP.html#st:103"><span class="id" title="variable">st</span></a> (<a class="idref" href="PLF.IMP.html#s_execute"><span class="id" title="axiom">s_execute</span></a> <a class="idref" href="PLF.IMP.html#st:103"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#stack:106"><span class="id" title="variable">stack</span></a> <a class="idref" href="PLF.IMP.html#p1:104"><span class="id" title="variable">p1</span></a>) <a class="idref" href="PLF.IMP.html#p2:105"><span class="id" title="variable">p2</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a id="lab171"></a><h4 class="section">Exercise: 3 stars, standard (stack_compiler_correct)</h4>

<div class="paragraph"> </div>

 Now we'll prove the correctness of the compiler implemented in the
    previous exercise.  Begin by proving the following lemma. If it
    becomes difficult, consider whether your implementation of
    <span class="inlinecode"><span class="id" title="var">s_execute</span></span> or <span class="inlinecode"><span class="id" title="var">s_compile</span></span> could be simplified. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a id="s_compile_correct_aux" class="idref" href="#s_compile_correct_aux"><span class="id" title="lemma">s_compile_correct_aux</span></a> : <span class="id" title="keyword">∀</span> <a id="st:107" class="idref" href="#st:107"><span class="id" title="binder">st</span></a> <a id="e:108" class="idref" href="#e:108"><span class="id" title="binder">e</span></a> <a id="stack:109" class="idref" href="#stack:109"><span class="id" title="binder">stack</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#s_execute"><span class="id" title="axiom">s_execute</span></a> <a class="idref" href="PLF.IMP.html#st:107"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#stack:109"><span class="id" title="variable">stack</span></a> (<a class="idref" href="PLF.IMP.html#s_compile"><span class="id" title="axiom">s_compile</span></a> <a class="idref" href="PLF.IMP.html#e:108"><span class="id" title="variable">e</span></a>) <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:107"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#e:108"><span class="id" title="variable">e</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Datatypes.html#::list_scope:x_'::'_x"><span class="id" title="notation">::</span></a> <a class="idref" href="PLF.IMP.html#stack:109"><span class="id" title="variable">stack</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
The main theorem should be a very easy corollary of that lemma. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="s_compile_correct" class="idref" href="#s_compile_correct"><span class="id" title="lemma">s_compile_correct</span></a> : <span class="id" title="keyword">∀</span> (<a id="st:110" class="idref" href="#st:110"><span class="id" title="binder">st</span></a> : <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a>) (<a id="e:111" class="idref" href="#e:111"><span class="id" title="binder">e</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#s_execute"><span class="id" title="axiom">s_execute</span></a> <a class="idref" href="PLF.IMP.html#st:110"><span class="id" title="variable">st</span></a> <span class="id" title="notation">[]</span> (<a class="idref" href="PLF.IMP.html#s_compile"><span class="id" title="axiom">s_compile</span></a> <a class="idref" href="PLF.IMP.html#e:111"><span class="id" title="variable">e</span></a>) <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="notation">[</span> <a class="idref" href="PLF.IMP.html#aeval"><span class="id" title="definition">aeval</span></a> <a class="idref" href="PLF.IMP.html#st:110"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#e:111"><span class="id" title="variable">e</span></a> <span class="id" title="notation">]</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a id="lab172"></a><h4 class="section">Exercise: 3 stars, standard, optional (short_circuit)</h4>


<div class="paragraph"> </div>

    Most modern programming languages use a "short-circuit" evaluation
    rule for boolean <span class="inlinecode"><span class="id" title="var">and</span></span>: to evaluate <span class="inlinecode"><span class="id" title="var">BAnd</span></span> <span class="inlinecode"><span class="id" title="var">b1</span></span> <span class="inlinecode"><span class="id" title="var">b2</span></span>, first evaluate
    <span class="inlinecode"><span class="id" title="var">b1</span></span>.  If it evaluates to <span class="inlinecode"><span class="id" title="var">false</span></span>, then the entire <span class="inlinecode"><span class="id" title="var">BAnd</span></span>
    expression evaluates to <span class="inlinecode"><span class="id" title="var">false</span></span> immediately, without evaluating
    <span class="inlinecode"><span class="id" title="var">b2</span></span>.  Otherwise, <span class="inlinecode"><span class="id" title="var">b2</span></span> is evaluated to determine the result of the
    <span class="inlinecode"><span class="id" title="var">BAnd</span></span> expression.

<div class="paragraph"> </div>

    Write an alternate version of <span class="inlinecode"><span class="id" title="var">beval</span></span> that performs short-circuit
    evaluation of <span class="inlinecode"><span class="id" title="var">BAnd</span></span> in this manner, and prove that it is
    equivalent to <span class="inlinecode"><span class="id" title="var">beval</span></span>.  (N.b. This is only true because expression
    evaluation in Imp is rather simple.  In a bigger language where
    evaluating an expression might diverge, the short-circuiting <span class="inlinecode"><span class="id" title="var">BAnd</span></span>
    would <i>not</i> be equivalent to the original, since it would make more
    programs terminate.) 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Module</span> <a id="BreakImp" class="idref" href="#BreakImp"><span class="id" title="module">BreakImp</span></a>.<br/>
</div>

<div class="doc">
<a id="lab173"></a><h4 class="section">Exercise: 4 stars, advanced (break_imp)</h4>


<div class="paragraph"> </div>

    Imperative languages like C and Java often include a <span class="inlinecode"><span class="id" title="var">break</span></span> or
    similar statement for interrupting the execution of loops. In this
    exercise we consider how to add <span class="inlinecode"><span class="id" title="var">break</span></span> to Imp.  First, we need to
    enrich the language of commands with an additional case. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a id="BreakImp.com" class="idref" href="#BreakImp.com"><span class="id" title="definition, inductive"><span id="BreakImp.com_rect" class="id"><span id="BreakImp.com_ind" class="id"><span id="BreakImp.com_rec" class="id"><span id="BreakImp.com_sind" class="id">com</span></span></span></span></span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="BreakImp.CSkip" class="idref" href="#BreakImp.CSkip"><span class="id" title="constructor">CSkip</span></a><br/>
&nbsp;&nbsp;| <a id="BreakImp.CBreak" class="idref" href="#BreakImp.CBreak"><span class="id" title="constructor">CBreak</span></a>                        <br/>
&nbsp;&nbsp;| <a id="BreakImp.CAsgn" class="idref" href="#BreakImp.CAsgn"><span class="id" title="constructor">CAsgn</span></a> (<a id="x:114" class="idref" href="#x:114"><span class="id" title="binder">x</span></a> : <span class="id" title="inductive">string</span>) (<a id="a:115" class="idref" href="#a:115"><span class="id" title="binder">a</span></a> : <a class="idref" href="PLF.IMP.html#aexp"><span class="id" title="inductive">aexp</span></a>)<br/>
&nbsp;&nbsp;| <a id="BreakImp.CSeq" class="idref" href="#BreakImp.CSeq"><span class="id" title="constructor">CSeq</span></a> (<a id="c1:116" class="idref" href="#c1:116"><span class="id" title="binder">c1</span></a> <a id="c2:117" class="idref" href="#c2:117"><span class="id" title="binder">c2</span></a> : <a class="idref" href="PLF.IMP.html#com:112"><span class="id" title="inductive">com</span></a>)<br/>
&nbsp;&nbsp;| <a id="BreakImp.CIf" class="idref" href="#BreakImp.CIf"><span class="id" title="constructor">CIf</span></a> (<a id="b:118" class="idref" href="#b:118"><span class="id" title="binder">b</span></a> : <a class="idref" href="PLF.IMP.html#bexp"><span class="id" title="inductive">bexp</span></a>) (<a id="c1:119" class="idref" href="#c1:119"><span class="id" title="binder">c1</span></a> <a id="c2:120" class="idref" href="#c2:120"><span class="id" title="binder">c2</span></a> : <a class="idref" href="PLF.IMP.html#com:112"><span class="id" title="inductive">com</span></a>)<br/>
&nbsp;&nbsp;| <a id="BreakImp.CWhile" class="idref" href="#BreakImp.CWhile"><span class="id" title="constructor">CWhile</span></a> (<a id="b:121" class="idref" href="#b:121"><span class="id" title="binder">b</span></a> : <a class="idref" href="PLF.IMP.html#bexp"><span class="id" title="inductive">bexp</span></a>) (<a id="c:122" class="idref" href="#c:122"><span class="id" title="binder">c</span></a> : <a class="idref" href="PLF.IMP.html#com:112"><span class="id" title="inductive">com</span></a>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a id="BreakImp.:com::'break'" class="idref" href="#BreakImp.:com::'break'"><span class="id" title="notation">&quot;</span></a>'break'" := <a class="idref" href="PLF.IMP.html#BreakImp.CBreak"><span class="id" title="constructor">CBreak</span></a> (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0).<br/>
<span class="id" title="keyword">Notation</span> <a id="BreakImp.:com:com_scope:'skip'" class="idref" href="#BreakImp.:com:com_scope:'skip'"><span class="id" title="notation">&quot;</span></a>'skip'"  :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#BreakImp.CSkip"><span class="id" title="constructor">CSkip</span></a> (<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id="6bf84ee0220c3a3f4df8e9da0b95f172" class="idref" href="#6bf84ee0220c3a3f4df8e9da0b95f172"><span class="id" title="notation">&quot;</span></a>x := y"  :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PLF.IMP.html#BreakImp.CAsgn"><span class="id" title="constructor">CAsgn</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="keyword">constr</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 85, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id="9693f1fd6e0ff7b00e2ee85219ea9702" class="idref" href="#9693f1fd6e0ff7b00e2ee85219ea9702"><span class="id" title="notation">&quot;</span></a>x ; y" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PLF.IMP.html#BreakImp.CSeq"><span class="id" title="constructor">CSeq</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 90, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id="BreakImp.:com:com_scope:'if'_x_'then'_x_'else'_x_'end'" class="idref" href="#BreakImp.:com:com_scope:'if'_x_'then'_x_'else'_x_'end'"><span class="id" title="notation">&quot;</span></a>'if' x 'then' y 'else' z 'end'" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PLF.IMP.html#BreakImp.CIf"><span class="id" title="constructor">CIf</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 89, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">z</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99) : <span class="id" title="var">com_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a id="BreakImp.:com:com_scope:'while'_x_'do'_x_'end'" class="idref" href="#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">&quot;</span></a>'while' x 'do' y 'end'" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PLF.IMP.html#BreakImp.CWhile"><span class="id" title="constructor">CWhile</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">in</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 89, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99) : <span class="id" title="var">com_scope</span>.<br/>

<br/>
</div>

<div class="doc">
Next, we need to define the behavior of <span class="inlinecode"><span class="id" title="var">break</span></span>.  Informally,
    whenever <span class="inlinecode"><span class="id" title="var">break</span></span> is executed in a sequence of commands, it stops
    the execution of that sequence and signals that the innermost
    enclosing loop should terminate.  (If there aren't any
    enclosing loops, then the whole program simply terminates.)  The
    final state should be the same as the one in which the <span class="inlinecode"><span class="id" title="var">break</span></span>
    statement was executed.

<div class="paragraph"> </div>

    One important point is what to do when there are multiple loops
    enclosing a given <span class="inlinecode"><span class="id" title="var">break</span></span>. In those cases, <span class="inlinecode"><span class="id" title="var">break</span></span> should only
    terminate the <i>innermost</i> loop. Thus, after executing the
    following...

<div class="paragraph"> </div>

       X := 0;
       Y := 1;
       while 0 &lt;&gt; Y do
         while true do
           break
         end;
         X := 1;
         Y := Y - 1
       end

<div class="paragraph"> </div>

    ... the value of <span class="inlinecode"><span class="id" title="var">X</span></span> should be <span class="inlinecode">1</span>, and not <span class="inlinecode">0</span>.

<div class="paragraph"> </div>

    One way of expressing this behavior is to add another parameter to
    the evaluation relation that specifies whether evaluation of a
    command executes a <span class="inlinecode"><span class="id" title="var">break</span></span> statement: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a id="BreakImp.result" class="idref" href="#BreakImp.result"><span class="id" title="definition, inductive"><span id="BreakImp.result_rect" class="id"><span id="BreakImp.result_ind" class="id"><span id="BreakImp.result_rec" class="id"><span id="BreakImp.result_sind" class="id">result</span></span></span></span></span></a> : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <a id="BreakImp.SContinue" class="idref" href="#BreakImp.SContinue"><span class="id" title="constructor">SContinue</span></a><br/>
&nbsp;&nbsp;| <a id="BreakImp.SBreak" class="idref" href="#BreakImp.SBreak"><span class="id" title="constructor">SBreak</span></a>.<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;st '=[' c ']=&gt;' st' '/' s"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="var">c</span> <span class="id" title="var">custom</span> <span class="id" title="var">com</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">st'</span> <span class="id" title="keyword">constr</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>).<br/>

<br/>
</div>

<div class="doc">
Intuitively, <span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><span class="id" title="var">s</span></span> means that, if <span class="inlinecode"><span class="id" title="var">c</span></span> is started in
    state <span class="inlinecode"><span class="id" title="var">st</span></span>, then it terminates in state <span class="inlinecode"><span class="id" title="var">st'</span></span> and either signals
    that the innermost surrounding loop (or the whole program) should
    exit immediately (<span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">SBreak</span></span>) or that execution should continue
    normally (<span class="inlinecode"><span class="id" title="var">s</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">SContinue</span></span>).

<div class="paragraph"> </div>

    The definition of the "<span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><span class="id" title="var">s</span></span>" relation is very
    similar to the one we gave above for the regular evaluation
    relation (<span class="inlinecode"><span class="id" title="var">st</span></span> <span class="inlinecode">=[</span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode">]=&gt;</span> <span class="inlinecode"><span class="id" title="var">st'</span></span>) -- we just need to handle the
    termination signals appropriately:

<div class="paragraph"> </div>

<ul class="doclist">
<li> If the command is <span class="inlinecode"><span class="id" title="var">skip</span></span>, then the state doesn't change and
      execution of any enclosing loop can continue normally.

<div class="paragraph"> </div>


</li>
<li> If the command is <span class="inlinecode"><span class="id" title="var">break</span></span>, the state stays unchanged but we
      signal a <span class="inlinecode"><span class="id" title="var">SBreak</span></span>.

<div class="paragraph"> </div>


</li>
<li> If the command is an assignment, then we update the binding for
      that variable in the state accordingly and signal that execution
      can continue normally.

<div class="paragraph"> </div>


</li>
<li> If the command is of the form <span class="inlinecode"><span class="id" title="keyword">if</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="keyword">then</span></span> <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode"><span class="id" title="keyword">else</span></span> <span class="inlinecode"><span class="id" title="var">c2</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span>, then
      the state is updated as in the original semantics of Imp, except
      that we also propagate the signal from the execution of
      whichever branch was taken.

<div class="paragraph"> </div>


</li>
<li> If the command is a sequence <span class="inlinecode"><span class="id" title="var">c1</span></span> <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" title="var">c2</span></span>, we first execute
      <span class="inlinecode"><span class="id" title="var">c1</span></span>.  If this yields a <span class="inlinecode"><span class="id" title="var">SBreak</span></span>, we skip the execution of <span class="inlinecode"><span class="id" title="var">c2</span></span>
      and propagate the <span class="inlinecode"><span class="id" title="var">SBreak</span></span> signal to the surrounding context;
      the resulting state is the same as the one obtained by
      executing <span class="inlinecode"><span class="id" title="var">c1</span></span> alone. Otherwise, we execute <span class="inlinecode"><span class="id" title="var">c2</span></span> on the state
      obtained after executing <span class="inlinecode"><span class="id" title="var">c1</span></span>, and propagate the signal
      generated there.

<div class="paragraph"> </div>


</li>
<li> Finally, for a loop of the form <span class="inlinecode"><span class="id" title="var">while</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode"><span class="id" title="tactic">do</span></span> <span class="inlinecode"><span class="id" title="var">c</span></span> <span class="inlinecode"><span class="id" title="keyword">end</span></span>, the
      semantics is almost the same as before. The only difference is
      that, when <span class="inlinecode"><span class="id" title="var">b</span></span> evaluates to true, we execute <span class="inlinecode"><span class="id" title="var">c</span></span> and check the
      signal that it raises.  If that signal is <span class="inlinecode"><span class="id" title="var">SContinue</span></span>, then the
      execution proceeds as in the original semantics. Otherwise, we
      stop the execution of the loop, and the resulting state is the
      same as the one resulting from the execution of the current
      iteration.  In either case, since <span class="inlinecode"><span class="id" title="var">break</span></span> only terminates the
      innermost loop, <span class="inlinecode"><span class="id" title="var">while</span></span> signals <span class="inlinecode"><span class="id" title="var">SContinue</span></span>. 
</li>
</ul>

<div class="paragraph"> </div>

 Based on the above description, complete the definition of the
    <span class="inlinecode"><span class="id" title="var">ceval</span></span> relation. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a id="BreakImp.ceval" class="idref" href="#BreakImp.ceval"><span class="id" title="definition, inductive"><span id="BreakImp.ceval_ind" class="id"><span id="BreakImp.ceval_sind" class="id">ceval</span></span></span></a> : <a class="idref" href="PLF.IMP.html#BreakImp.com"><span class="id" title="inductive">com</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.result"><span class="id" title="inductive">result</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <a class="idref" href="PLF.IMP.html#state"><span class="id" title="definition">state</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <a id="BreakImp.E_Skip" class="idref" href="#BreakImp.E_Skip"><span class="id" title="constructor">E_Skip</span></a> : <span class="id" title="keyword">∀</span> <a id="st:127" class="idref" href="#st:127"><span class="id" title="binder">st</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:127"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.CSkip"><span class="id" title="constructor">CSkip</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st:127"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SContinue"><span class="id" title="constructor">SContinue</span></a><br/>
&nbsp;&nbsp;<br/>
<br/>
&nbsp;&nbsp;<span class="id" title="keyword">where</span> <a id="2b326eb0d5dcd2404a8e7abc4d2a6400" class="idref" href="#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">&quot;</span></a>st '=[' c ']=&gt;' st' '/' s" := (<a class="idref" href="PLF.IMP.html#ceval:126"><span class="id" title="inductive">ceval</span></a> <span class="id" title="var">c</span> <span class="id" title="var">st</span> <span class="id" title="var">s</span> <span class="id" title="var">st'</span>).<br/>

<br/>
</div>

<div class="doc">
Now prove the following properties of your definition of <span class="inlinecode"><span class="id" title="var">ceval</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a id="BreakImp.break_ignore" class="idref" href="#BreakImp.break_ignore"><span class="id" title="lemma">break_ignore</span></a> : <span class="id" title="keyword">∀</span> <a id="c:128" class="idref" href="#c:128"><span class="id" title="binder">c</span></a> <a id="st:129" class="idref" href="#st:129"><span class="id" title="binder">st</span></a> <a id="st':130" class="idref" href="#st':130"><span class="id" title="binder">st'</span></a> <a id="s:131" class="idref" href="#s:131"><span class="id" title="binder">s</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:129"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com::'break'"><span class="id" title="notation">break</span></a><a class="idref" href="PLF.IMP.html#9693f1fd6e0ff7b00e2ee85219ea9702"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#c:128"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':130"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#s:131"><span class="id" title="variable">s</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:129"><span class="id" title="variable">st</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#st':130"><span class="id" title="variable">st'</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="BreakImp.while_continue" class="idref" href="#BreakImp.while_continue"><span class="id" title="lemma">while_continue</span></a> : <span class="id" title="keyword">∀</span> <a id="b:132" class="idref" href="#b:132"><span class="id" title="binder">b</span></a> <a id="c:133" class="idref" href="#c:133"><span class="id" title="binder">c</span></a> <a id="st:134" class="idref" href="#st:134"><span class="id" title="binder">st</span></a> <a id="st':135" class="idref" href="#st':135"><span class="id" title="binder">st'</span></a> <a id="s:136" class="idref" href="#s:136"><span class="id" title="binder">s</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:134"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#b:132"><span class="id" title="variable">b</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a> <a class="idref" href="PLF.IMP.html#c:133"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':135"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#s:136"><span class="id" title="variable">s</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#s:136"><span class="id" title="variable">s</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SContinue"><span class="id" title="constructor">SContinue</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="BreakImp.while_stops_on_break" class="idref" href="#BreakImp.while_stops_on_break"><span class="id" title="lemma">while_stops_on_break</span></a> : <span class="id" title="keyword">∀</span> <a id="b:137" class="idref" href="#b:137"><span class="id" title="binder">b</span></a> <a id="c:138" class="idref" href="#c:138"><span class="id" title="binder">c</span></a> <a id="st:139" class="idref" href="#st:139"><span class="id" title="binder">st</span></a> <a id="st':140" class="idref" href="#st':140"><span class="id" title="binder">st'</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#beval"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st:139"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#b:137"><span class="id" title="variable">b</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#:::'true'"><span class="id" title="notation">true</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:139"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c:138"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':140"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SBreak"><span class="id" title="constructor">SBreak</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:139"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#b:137"><span class="id" title="variable">b</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a> <a class="idref" href="PLF.IMP.html#c:138"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':140"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SContinue"><span class="id" title="constructor">SContinue</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="BreakImp.seq_continue" class="idref" href="#BreakImp.seq_continue"><span class="id" title="lemma">seq_continue</span></a> : <span class="id" title="keyword">∀</span> <a id="c1:141" class="idref" href="#c1:141"><span class="id" title="binder">c1</span></a> <a id="c2:142" class="idref" href="#c2:142"><span class="id" title="binder">c2</span></a> <a id="st:143" class="idref" href="#st:143"><span class="id" title="binder">st</span></a> <a id="st':144" class="idref" href="#st':144"><span class="id" title="binder">st'</span></a> <a id="st'':145" class="idref" href="#st'':145"><span class="id" title="binder">st''</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:143"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c1:141"><span class="id" title="variable">c1</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':144"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SContinue"><span class="id" title="constructor">SContinue</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st':144"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c2:142"><span class="id" title="variable">c2</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st'':145"><span class="id" title="variable">st''</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SContinue"><span class="id" title="constructor">SContinue</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:143"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c1:141"><span class="id" title="variable">c1</span></a> <a class="idref" href="PLF.IMP.html#9693f1fd6e0ff7b00e2ee85219ea9702"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#c2:142"><span class="id" title="variable">c2</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st'':145"><span class="id" title="variable">st''</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SContinue"><span class="id" title="constructor">SContinue</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a id="BreakImp.seq_stops_on_break" class="idref" href="#BreakImp.seq_stops_on_break"><span class="id" title="lemma">seq_stops_on_break</span></a> : <span class="id" title="keyword">∀</span> <a id="c1:146" class="idref" href="#c1:146"><span class="id" title="binder">c1</span></a> <a id="c2:147" class="idref" href="#c2:147"><span class="id" title="binder">c2</span></a> <a id="st:148" class="idref" href="#st:148"><span class="id" title="binder">st</span></a> <a id="st':149" class="idref" href="#st':149"><span class="id" title="binder">st'</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:148"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c1:146"><span class="id" title="variable">c1</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':149"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SBreak"><span class="id" title="constructor">SBreak</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:148"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c1:146"><span class="id" title="variable">c1</span></a> <a class="idref" href="PLF.IMP.html#9693f1fd6e0ff7b00e2ee85219ea9702"><span class="id" title="notation">;</span></a> <a class="idref" href="PLF.IMP.html#c2:147"><span class="id" title="variable">c2</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':149"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SBreak"><span class="id" title="constructor">SBreak</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a id="lab174"></a><h4 class="section">Exercise: 3 stars, advanced, optional (while_break_true)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a id="BreakImp.while_break_true" class="idref" href="#BreakImp.while_break_true"><span class="id" title="lemma">while_break_true</span></a> : <span class="id" title="keyword">∀</span> <a id="b:150" class="idref" href="#b:150"><span class="id" title="binder">b</span></a> <a id="c:151" class="idref" href="#c:151"><span class="id" title="binder">c</span></a> <a id="st:152" class="idref" href="#st:152"><span class="id" title="binder">st</span></a> <a id="st':153" class="idref" href="#st':153"><span class="id" title="binder">st'</span></a>,<br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:152"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">while</span></a> <a class="idref" href="PLF.IMP.html#b:150"><span class="id" title="variable">b</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">do</span></a> <a class="idref" href="PLF.IMP.html#c:151"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.:com:com_scope:'while'_x_'do'_x_'end'"><span class="id" title="notation">end</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':153"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SContinue"><span class="id" title="constructor">SContinue</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#beval"><span class="id" title="definition">beval</span></a> <a class="idref" href="PLF.IMP.html#st':153"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#b:150"><span class="id" title="variable">b</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#:::'true'"><span class="id" title="notation">true</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <a id="st'':154" class="idref" href="#st'':154"><span class="id" title="binder">st''</span></a><a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="PLF.IMP.html#st'':154"><span class="id" title="variable">st''</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c:151"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st':153"><span class="id" title="variable">st'</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#BreakImp.SBreak"><span class="id" title="constructor">SBreak</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
<div class="paragraph"> </div>

<a id="lab175"></a><h4 class="section">Exercise: 4 stars, advanced, optional (ceval_deterministic)</h4>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <a id="BreakImp.ceval_deterministic" class="idref" href="#BreakImp.ceval_deterministic"><span class="id" title="lemma">ceval_deterministic</span></a>: <span class="id" title="keyword">∀</span> (<a id="c:155" class="idref" href="#c:155"><span class="id" title="binder">c</span></a>:<a class="idref" href="PLF.IMP.html#BreakImp.com"><span class="id" title="inductive">com</span></a>) <a id="st:156" class="idref" href="#st:156"><span class="id" title="binder">st</span></a> <a id="st1:157" class="idref" href="#st1:157"><span class="id" title="binder">st1</span></a> <a id="st2:158" class="idref" href="#st2:158"><span class="id" title="binder">st2</span></a> <a id="s1:159" class="idref" href="#s1:159"><span class="id" title="binder">s1</span></a> <a id="s2:160" class="idref" href="#s2:160"><span class="id" title="binder">s2</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:156"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c:155"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st1:157"><span class="id" title="variable">st1</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#s1:159"><span class="id" title="variable">s1</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st:156"><span class="id" title="variable">st</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">=[</span></a> <a class="idref" href="PLF.IMP.html#c:155"><span class="id" title="variable">c</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">]=&gt;</span></a> <a class="idref" href="PLF.IMP.html#st2:158"><span class="id" title="variable">st2</span></a> <a class="idref" href="PLF.IMP.html#2b326eb0d5dcd2404a8e7abc4d2a6400"><span class="id" title="notation">/</span></a> <a class="idref" href="PLF.IMP.html#s2:160"><span class="id" title="variable">s2</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#::type_scope:x_'-&gt;'_x"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PLF.IMP.html#st1:157"><span class="id" title="variable">st1</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#st2:158"><span class="id" title="variable">st2</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="PLF.IMP.html#s1:159"><span class="id" title="variable">s1</span></a> <a class="idref" href="http://rocq-prover.org/doc/V9.1.0/stdlib//Corelib.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PLF.IMP.html#s2:160"><span class="id" title="variable">s2</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
 <span class="id" title="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<font size=-2>&#9744;</font> 
</div>
<div class="code">
<span class="id" title="keyword">End</span> <a class="idref" href="PLF.IMP.html#BreakImp"><span class="id" title="module">BreakImp</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab176"></a><h4 class="section">Exercise: 4 stars, standard, optional (add_for_loop)</h4>


<div class="paragraph"> </div>

    Add C-style <span class="inlinecode"><span class="id" title="keyword">for</span></span> loops to the language of commands, update the
    <span class="inlinecode"><span class="id" title="var">ceval</span></span> definition to define the semantics of <span class="inlinecode"><span class="id" title="keyword">for</span></span> loops, and add
    cases for <span class="inlinecode"><span class="id" title="keyword">for</span></span> loops as needed so that all the proofs in this
    file are accepted by Coq.

<div class="paragraph"> </div>

    A <span class="inlinecode"><span class="id" title="keyword">for</span></span> loop should be parameterized by (a) a statement executed
    initially, (b) a test that is run on each iteration of the loop to
    determine whether the loop should continue, (c) a statement
    executed at the end of each loop iteration, and (d) a statement
    that makes up the body of the loop.  (You don't need to worry
    about making up a concrete Notation for <span class="inlinecode"><span class="id" title="keyword">for</span></span> loops, but feel free
    to play with this too if you like.) 
</div>
<div class="code">

<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://rocq-prover.org/">coqdoc</a>
</div>

</div>

</body>
</html>